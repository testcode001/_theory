1.抽取.代码复用(相同抽取不同抽象).文件复用.view对象复用(功能复用)：便于修改
根据不同的请求参数，判断.映射成下一步全局唯一标示符，传递.通讯+数据独立，做出相应的处理	
响应方制定下一步全局唯一标识符，并由请求方发送给响应方，传递.通讯+数据独立，做出相应的处理	
2.精通业务逻辑和功能需求：分清层次，各层之间面向接口编程，设计出良好的程序接口
模块之间面向接口编程：便于扩展即模块替换 (新增类和方法而不是修改已有代码)	
面向对象：对数据的一种抽取、封装、模拟现实.优化现实，便于管理
对系统来说，新增加一个类的代码风险要大大低于对已有类代码的修改.我觉得这个也是设计模式的立足点吧
(如果你喜欢修改已有代码,那么设计模式就没有多大意义了
隔离，解耦、只用修改一边，而不用两边同时修改 (类似代理的作用)
(dao层面向接口编程，更改数据库时，只需更改底层实现而无需修改上层代码)
类.面向对象的三大特性：封装、继承、多态
3.设计模式.代码重构：封装.继承.多态以实现分层
单例模式：1.私有化构造函数、2.自身属性成员、3.public static getInstance()方法 
观察者模式: 观察对象、被观察对象又叫主题对象、观察对象需要在被观察对象上注册、被观察对象调用notify方法，观察对象接到通知后作出相应改变
单例.观察者.工厂
动态代理、包装
包装模式与代理模式的区别
适配器模式：中间人，把接口不一致的两个插件接合起来
解释数据库表每个字段的意思



回调函数：底层定义接口(和set方法)，上层传递实例对象，底层调用上层。(回调函数.监听器)
方法先调用自身的，再调用其他的。父类引用指向子类对象时，实例方法先调用子类的，即多态性。
系统间调用：客户端-服务器模式
webService远程进程调用：类调用方法，传递参数、数据传输协议(xml、json)
B/S：http协议
C/S：Socket连接，TCP.UDP协议
1.httpClient直接访问
2.提供jar包(.so库)，开放api接口	(封装了httpClient调用)

rpc： 
服务器端：接口.注解、实现类
客户端：接口.注解+动态代理InvocationHandler.CGlib
--------------------------------------------------------------------------------
代码整洁之道
对于不熟悉或者不确定的代码：新增而不要修改原有代码业务逻辑
组合优于继承：避免父类修改时，造成子类的大量改动








