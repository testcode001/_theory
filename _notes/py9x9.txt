#! /usr/bin/python
print '\n9x9 Table\n'
for i in range(1, 10) :
    for j in range(1, i+1) :
        print j, 'x', i, '=', j*i, '\t',
        # print '%d x %d = %d\t' %(j, i, j*i),
    print '\n'
print '\nDone!'


https://www.liaoxuefeng.com/wiki/897692888725344/983420006222912
http://www.w3cschool.cc/python/python-exceptions.html
python:
http://www.cnblogs.com/IPrograming/p/Python-socket.html
http://blog.csdn.net/wklken/article/details/7935220

http://blog.csdn.net/sasoritattoo/article/details/10020547
windows＋Python＋virtualenv

pip install SomePackage
pip search "query"
pip install --upgrade SomePackage
pip install --upgrade SomePackage==version


面向对象编程导包：from...import...
1 from 包名(即路径) import python文件名 (或者import python文件名)， 如：from pymongo import (common, helpers,message)
2 from python文件名 import */类名/函数名
面向过程编程导包：import...
1 import 包名  即import包名目录下的__init__.py文件，该文件的内容是导入同一包下的所有文件。python包的__init__.py文件即为导入该包时的初始化文件，python类的__init__(self)函数是构造函数。
2 import python文件名 #面向过程编程，使用A中所有的属性和方法（即变量和函数）。面向对象编程必须使用from...import...的形式。
python文件名即model名
module：单个模块，一般是单个python文件；
package：多个Python文件的组合。

在于import A  和 from A import *两种的引用机制不同
import A 是指使用A中所有的属性和方法（即变量和函数），在B中使用时，一定要A.属性 A.方法来调用，这时候调用的是A中原有的内容
而from A import *是对A中所有属性和方法的引用，也就是A中所有属性和方法的一个备份，对于方法（即函数）可以正常使用，但是对于属性（即变量）的使用却有问题，

PYTHONPATH是Python搜索路径，默认我们import的模块都会从PYTHONPATH里面寻找。
进入python cmd，然后输入下面的代码可以打印PYTHONPATH：
import sys 
print sys.path
python的*args和**kwargs：*args表示位置参数, **kwargs表示关键字参数, 这其实就是 Python 中可变参数的两种形式，并且 *args 必须放在 **kwargs 的前面，因为位置参数必须在关键字参数的前面。
*args单星号创建了元组(列表)，其内容则是来自函数调用的位置参数。**kwargs双星号创建了字典，其内容来自函数调用的关键字参数，（在这些定义变元后）

-----------------------------------------------------------------------------------------------------------------------------
【python内置属性】:
__name__   		object的名字，
__file__     	路径名字
__main__      	执行的主module的名字
__doc__    		是对该module的描述，字符串
__builtins__
__package__
__dict__
当一个python文件作为单独的程序运行的时候，__name__ 的值将是一个特别的缺省值__main__，这条语句if __name__ == '__main__':就是程序的入口。
如果是import模块, 那么 __name__ 的值通常为模块的文件名。

【python内置函数】：
filter
map
reduce
http://jianfeihit.iteye.com/blog/1835272
(1) help()函数
help('os')函数：查看module文件路径及源码
如果传一个字符串做参数的话，它会自动搜索以这个字符串命名的模块，方法等。
如果传入的是一个对象，就会显示这个对象的类型的帮助。
help('functionname')
(2) dir()函数
dir()函数返回任意对象的属性和方法列表。
包括模块对象、函数对象、字符串对象、列表对象、字典对象等。
dir() 函数适用于所有对象类型，包括字符串、整数、列表、元组、字典、函数、定制类、类实例和类方法。
dir(__builtins__)  #内置
(3) input()与raw_input()函数
(4) print()函数
(5) type()函数
【python类的内置的类属性】：
# 类的内置属性有：
__dict__:类的属性
__bases__:类的所有父类构成的元组  # 说明python支持多继承
__doc__:类的文档字符串
__name__:类名
__module__:类定义所在的模块
# 实例属性：
__dict__:实例的属性
__class__:实例对应的类
【python类的内置私有函数】：
__init__ : 构造函数，在生成对象时调用
__del__ : 析构函数，释放对象时使用
__repr__ : 打印，转换
__setitem__ : 按照索引赋值
__getitem__: 按照索引获取值
__len__: 获得长度
__cmp__: 比较运算
__call__: 函数调用，即实例对象可当做函数一样调用
__sub__: 减运算
__mul__: 乘运算
__truediv__: 除运算
__mod__: 求余运算
__pow__: 乘方运算

【python标准库】：
itertools http://docs.python.org/2/library/itertools.html 迭代器模块 https://www.liaoxuefeng.com/wiki/897692888725344/983420006222912
functools http://docs.python.org/2/library/functools.html 学好python有必要掌握上面这两个库吧，
re 正则
subprocess http://docs.python.org/2/library/subprocess.html 调用shell命令的神器
pdb 调试
traceback 调试
pprint 漂亮的输出
logging 日志
threading和multiprocessing 多线程
urllib/urllib2/httplib http库，httplib底层一点，推荐第三方的库requests
os/sys 系统，环境相关
Queue 队列
pickle/cPickle 序列化工具
hashlib md5, sha等hash算法
cvs
json/simplejson python的json库，据so上的讨论和benchmark，simplejson的性能要高于json
timeit 计算代码运行的时间等等
cProfile python性能测量模块
glob 类似与listfile，可以用来查找文件
atexit 有一个注册函数，可用于正好在脚本退出运行前执行一些代码
dis python 反汇编，当对某条语句不理解原理时，可以用dis.dis 函数来查看代码对应的python 解释器指令等等。
Tkinter模块(“Tk 接口”)是Python的标准Tk GUI工具包的接口

【搜索：python常用第三方库】
Python第三方库大全看这一篇就够了
https://zhuanlan.zhihu.com/p/384362763
https://github.com/jobbole/awesome-python-cn
https://www.cnblogs.com/jiangchunsheng/p/9275881.html
字符串处理、时间日期处理、文件处理、
访问网络: Requests
Django/Flask：web服务器
图像处理库:  pil(python image library,python2)、Pillow(64位, python3)
python-OpenCV
python数据处理： 
Numpy
Pandas是一个强大的分析结构化数据的工具集;它是基于Numpy(提供高性能的矩阵运算), 这意味着大多数NumPy方法都是Pandas中已有的函数;Pandas可用于数据挖掘和数据分析，同时也提供数据清洗功能。
MatplotLib：分析完数据后，还可以Matplotlib将其可视化 https://github.com/matplotlib/matplotlib
python桌面GUI：
PyQt5
Tkinter：Python标准库，用于为基于桌面的应用程序创建图形用户界面
Schedule：周期性地执行某个Python任务。能够容纳crontab的所有基本功能

beautiful soup解析html页面：beautifulsoup4+re正则
正则表达式匹配：字符种类[].字符个数{}.小括号()分组，以什么开头^ 以什么结尾$
正则表达式匹配模式：贪婪模式、非贪婪模式和独占模式
正则表达式匹配任意字符：(.*?)
爬虫框架：Scrapy
数据库处理：pymongo
web自动化测试：Selenium



-----------------------------------------------------------------------------------------------------------------------------
python函数中参数传递方式：Python值传递和引用传递是根据实际参数的类型不同进行区分的，如下所示：
值传递：指的是实参类型为不可变类型（数字、字符串、元组）；
引用传递（或叫地址传递）：指的是实参类型为可变类型（列表，字典，set 集合，np矩阵，torch.Tensor矩阵）

python查看类或者方法的定义：直接在代码中打出该类，或者调用该方法查看即可
python自动导包：输完所需包名直接回车即可
python函数的多个返回值，其实是返回了一个元组，当然也可以返回列表，字典等。只需在return后跟多个值，并依次用逗号分隔： return date.year, date.month, date.day
python既可以面向过程.函数，也可以面向对象编程
面向对象时，把python当做java习惯来写，兼容一些语法上的差异即可

python的注释符和shell类似，跟java不一样
#单行注释
'''
多行注释
'''
"""
多行注释
"""
字符串用单引号或双引号来表示
字符串查找.替换.拼接.截取.分割.判断包含/相等.下标.长度、切片操作模版如下：string[start: end: step]
Python字符串前加f,r,u,b的含义：
python字符串前面加“f”表示字符串内支持大括号{var}取变量值的python表达式
python字符串前面加“r”是为了防止字符转义。如果字符串中出现“\t”，不加“r”的话“\t”就会被转义，而加了“r”之后“\t”就能保留原有的样子。
python字符串前加"u"一般出现在中文字符串前，防止出现乱码
python字符串前加"b"表示这是一个bytes类型对象,在网络编程中,服务器和浏览器只认bytes类型数据

容器.算法.迭代器：
容器的创建.c.r.u.d操作.截取.下标.长度.判断包含、切片操作
小括号，中括号，大括号即定义元组,列表list, map字典.json串
(1,2,3,4) 定义元组，即常量一旦创建后则不能修改，经常作为函数返回值。元组tuple.即只读列表数组
['a','b','c'] 定义列表list
{"key1":"value1", "key2":"value2"} 定义字典map.即json字符串
animals = {'cat', 'dog', 'fish'}  大括号也可以用来定义集合set
列表的切片操作：
list = [1,2,3,4,5]
print(list[1: 4: 2])  #开始:结尾:步长  #输出2 4
https://blog.csdn.net/qq_37431461/article/details/122097621

变量，语句，类，函数的声明定义及调用
类.函数的定义、循环.选择语句以冒号结束: 有冒号的下一行往往要缩进：严格语法缩进
python用缩进来保持类.函数.循环.选择语句等代码块的整体性，而不是用大括号。大括号是用来定义字典类型变量用的.即json串
python中变量.函数.语句可以定义在任何地方，如语句可写在函数外边
python中的语句末尾不需要分号;
\ 用于连接本行和下一行
def xxxxxx：
（空格）xxxxx
还有
for xxxxxx：
（空格）xxxxx
if xxxxxx：
（空格）xxxxx

def func(*tuple):  参数为元组  def func(**dict):参数为字典, 都是可变参数，可为空  
*和**，也可以在调用的时候使用，即解包裹(unpacking)
def func(a,b,c):
    print a,b,c
param = (1,3,4)
func(*param)

异常捕获语法：raise手动抛出异常
try:
	正常代码块........
except Exception:
	捕获异常后，代码块.......
else:
	当无异常时，才会执行这个代码块(除非直接在try块中就return才不会执行这里)


python支持多重继承class D(A,B,C):
print(className.mro()) #打印类的继承结构mro(Method Resolution Order)
print(className.__subclasses__()) #打印子类
子类构造函数调用父类构造函数语法：父类名.__init__(self,[参数])
经典类：没有继承（object）
新式类：继承了（object） python3.x 定义一个类时，默认继承（object) ,建议使用新式类
Student.__bases__	# 可以通过__bases__查看基类，查看当前的类是不是新式类
***python中没有方法的重载。定义多个重名的方法时，只有最后一个有效。
python类的构造函数是固定的：def __init__(self): 	#第一个参数必须是self
class AClass:
def __init__(self,new_msg): #python的构造函数是固定的且第一个参数必须是self(名字也可以不叫self，也可以叫abc，但第一个参数的作用是固定的), 支持重载 
私有属性可通过”实例对象._类名__私有属性/方法名“在类外部访问。 私有属性被重命名后的名称可通过print(dir(实例对象))查看
Python中如何知道函数的返回类型：可以使用type()函数查看函数返回值的变量类型print(type(returnValue))，另外还可以通过dir()，help()函数获取变量的信息
python单利模式： print(id(实例对象))#可用id()判断是不是同一个实例对象.即单利模式

属性分为实例属性和类属性：
在构造函数/实例方法中通过self.属性名定义， 或者通过 实例.属性名 访问的属性就是实例属性(否则就是个局部变量)
实例属性和类属性都定义在类中，区别在于实例属性定义在方法内，类属性定义在方法外。
在函数外且在类里面定义的变量就是类属性，类属性能被类和实例数据共享并访问。而实例属性只能被实例访问。
函数外定义变量为全局变量：函数内修改全局变量时，函数内必须先用用golbal声明全局变量，再做赋值等修改操作
类属性修改：
类可以修改类属性
类方法可以修改类属性；
对象不能修改类属性（因为修改时相当于动态添加对象属性）；
对象方法可以修改类属性
对象属性修改：
对象可以修改对象属性；
对象方法可以修改对象属性；

Python属性和方法的访问权限通过单下划线和双下划线来区分：
使用一个下画线“_”开头的属性或方法为保护(protected)属性或方法，只能在类或其派生类内部以“self._属性名或方法名”的方式使用；
使用两个下画线“__”开头的属性或方法为保护(private)属性或方法，只能在类内部以“self._属性名或方法名”的方式使用；
Python属性和方法的访问权限默认为公有(public)属性或方法，可在类的外部直接访问，在类内部以“self.属性名或方法名”的方式使用。
student.__age = 21 # 类外部访问私有类属性时，则会重新创建一个私有属性为__age
_xxx单下划线开头的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；不能用于’from module import *’ 
__xxx双下划线开头的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。在类内部访问用self.__xxx
__functionName()__以双下划线开头和结尾的方法，是由系统调用的，即回调函数。例如：def __init__(self,new_msg): 即构造函数 
如果父类中有一个__xxx的变量的话，父类中的变量不会被子类中__xxx覆盖。如果是非私有的字段xxx，就会被子类中的覆盖掉。所以私有化也是保护关键变量的好选择。
Python中类属性和实例属性按照从下往上的查找机制进行查找
核心风格：避免用下划线_作为变量名的开始。
python的私有属性是一种伪私有属性，那么它是怎么实现的呢？主要靠的是一个名字重整机制，比如重改__x为另外一个名称。目的是：1.防止外界直接访问。2.防止被子类同名称属性覆盖

方法分为实例方法.构造方法、类方法、静态方法和普通方法：
***类和实例都可以访问实例方法、类方法、静态方法，而普通方法只能通过类访问(函数可用python文件名来直接调用)
构造函数和实例函数的第一个参数必须是self(指明是哪个对象调用的函数)且至少有一个参数。类也可以调用实例方法，但需要传递实例对象：Person.show(Aa)
类方法第一个参数必须是cls，用装饰器(即注解)@classmethod修饰。  Python装饰器的应用场景http://c.biancheng.net/view/5410.html
静态方法用装饰器@staticmethod修饰，静态方法和当前对象和当前类没有任何关系
普通方法即第一个参数不是self且没有相应的注解修饰，只能通过类访问
类使用需要实例化。 如：b.B()。如：假设模块b中有类B，其中有变量v1，方法f1，类方法f2。那在模块a中调用方法是：
import b
a = b.B()
aa = a.v1 #引用变量
bb = a.f1() #引用函数
cc = b.B.f2() #引用类方法
https://blog.csdn.net/qq_40433737/article/details/105251725

python的isinstane(obj,Type)内置方法用来判断实例对象是否属于某个类
闭包 即代码块？
装饰器函数.即注解
生成器函数

Python中的基类object和元类metaclass=type:
元类继承自type类, 元类是类的类。类定义类的实例(即对象)的行为，而元类定义类的行为。类是元类的实例。
class关键字就是使用元类通过__new__和__init__创建出一个类
我们平常所用的类其实是用type创建出来的。而元类继承自type类，这意味着，它跟type一样，是用来创建类的，可以理解为两者是同一个级别，只是元类可以在创建类的时候都再干一些自定义的活

type是Python中常见的元类。type它本身是一个类，并且是它自己的类型。
元类最常用作类工厂。当通过调用类创建对象时，Python通过调用元类来创建一个新类(当执行“ class”语句时)。
因此，将元类与普通方法__init__和__new__方法结合使用，可以使您在创建类时做“额外的事情”，例如使用某些注册表注册新类或将其完全替换为其他类。
当class执行语句时，Python首先将class语句的主体作为普通代码块执行。生成的名称空间(字典)保留了将来类的属性。通过查看要成为类的基类(继承了元类)，
要成为类的__metaclass__属性(如果有)或__metaclass__全局变量来确定元类。然后使用该类的名称，基数和属性调用该元类以实例化它。
https://blog.csdn.net/weixin_28979345/article/details/112958974

-----------------------------------------------------------------------------------------------------------------------------
python多线程.线程池，类似于java：
线程池的基类是 concurrent.futures 模块中的 Executor。
Executor 提供了两个子类，即 ThreadPoolExecutor 和 ProcessPoolExecutor，其中 ThreadPoolExecutor 用于创建线程池，而 ProcessPoolExecutor 用于创建进程池。
from concurrent.futures import ThreadPoolExecutor
import threading  # python原生线程
Python的线程是有全局解释器锁 GIL(global interpreter lock)锁的，所以是单核的。python在执行的时候同一时刻只允许一个线程运行,因为存在GIL，所以cpython中无法利用多核，解决方法是多进程+协程
Python的进程每个都有独立的GIL锁，所以是多核的，但是每个都需要独立的分配内存空间，所以空间占用大
多线程实现的四种方式分别是：
1.from concurrent.futures import ThreadPoolExecutor # python原生线程池，这个更主流
2.import threadpool  								# 线程池，需要 pip install threadpool，很早之前的
multiprocessing下面有两种：
3.from multiprocessing.dummy import Pool as ThreadPool  # 线程池
4.from multiprocessing.pool import ThreadPool   # 线程池，用法无区别，唯一区别这个是线程池
http://c.biancheng.net/view/2627.html
https://blog.csdn.net/ye__mo/article/details/123664568
https://blog.csdn.net/u012969412/article/details/82768882
Python全局解释器锁(GIL)是一种互斥锁，仅允许一个线程持有Python解释器的控制权。
全局解释器锁是计算机程序设计语言解释器用于同步线程的工具，使得在同一进程内任何时刻仅有一个线程在执行。
准确的说，GIL的线程安全是粗粒度的。也就是说，有GIL都不意味着线程安全。比如python的每行代码不是原子化的操作。比如n = n+1这步，不是一次性执行的。
查看python编译后的字节码执行过程，可以看到n = n +1 操作分成了四步完成：1.加载全局变量n，2.加载常数1，3.进行二进制加法运算，4.将运算结果存入变量n。
根据前面的线程释放GIL锁原则，线程a执行这四步的过程中，有可能会让出GIL。如果这样，n=n+1的运算过程就被打乱了。最后的结果中，得到一个非零的n也就不足为奇。	
全局解释器锁的好处：1、避免了大量的加锁解锁的好处; 2、使数据更加安全，解决多线程间的数据完整性和状态同步。
全局解释器锁的劣势：多核处理器退化成单核处理器，只能并发不能并行。
python3这个解释器是由C语言写的，GIL锁也是在这个解释器里才有的一种机制。例如java写的Jython就没有GIL。
如果要充分利用多核的性能有几个方法：
用多进程，不用多线程。
换一个解释器，不用python3,用jython等。
发挥python胶水语言的特性，在线程中用其他语言实现。
thread-safe不是谁都能驾驭的，想做cpu密集型的代码就用c或者c++，调用的时候释放gil就行。比如常用的numpy，有部分操作操作会直接释放gil。

python多进程：一般计算(CPU)密集型任务适合多进程，IO密集型任务适合多线程；
from multiprocessing import Process
p = Process(target=func,args=('来玩啊！')) #将函数注册到一个进程中，p是一个进程对象，此时还没有启动进程
p.daemon= True #设置子进程为守护进程。 即若主进程退出，子进程就会自动销毁，不会再执行任何代码。  没有这个设置时，默认主进程会等待所有子进程结束后才会退出程序。
p.start() #告诉操作系统，给我开启一个进程，func这个函数就被我们新开的这个进程执行了

subprocess这个模块来产生子进程,并连接到子进程的标准输入/输出/错误中去，还可以得到子进程的返回值。
subprocess模块定义了一个类Popen：
p=subprocess.Popen("ls",shell=True,stdout=subprocess.PIPE) 
(out, error) = p.communicate()
print(out)
print(error)
subprocess.Popen.poll()，用于检查子进程是否已经结束 0：正常结束  1：sleep   2：子进程不存在  5：kill   None：在运行
env参数：如果env不是None，则子程序的环境变量由env的值来设置，而不是默认那样继承父进程的环境变量。
注意，即使你只在env里定义了某一个环境变量的值，也会阻止子程序得到其他的父进程的环境变量（也就是说，如果env里只有1项，那么子进程的环境变量就只有1个了）
http://t.zoukankan.com/viviancc-p-3056960.html
python subprocess模块 查看子进程状态的2种方式：
一:循环 忙等 子进程结束
 import subprocess  
 import os  
 import time  
 tt = '555'  
 cmd = "python /home/100003/python/mypython/sub2.py "+" 333"+" 444 "+tt  
 print time.time()  
 sub2 = subprocess.Popen(cmd, shell=True)  
 while 1:  
     ret1 = subprocess.Popen.poll(sub2)  
     if ret1 == 0:  
         print sub2.pid,'end'  
         break  
     elif ret1 is None:  
         print  'running'  
         time.sleep(1)  
     else:  
         print sub2.pid,'term'  
         break  
 print time.time()  
二:子进程结束 立即返回 使用select模块 同时可设置子进程的超时时间
import subprocess  
 import select  
 import time  
 import signal  
 import os  
   
 tt = '555'  
 cmd = "python /home/100003/python/mypython/sub2.py "+" 333"+" 444 "+tt  
 timeout = 3  
 pro = subprocess.Popen(cmd, stdout=subprocess.PIPE,shell = True)  
 print time.time()  
 while 1:  
     while_begin = time.time()  
     print 'timeout',timeout  
     fs = select.select([pro.stdout], [], [], timeout)  
     if pro.stdout in fs[0]:  
         tmp = pro.stdout.read()  
         print 'read', tmp  
         if not tmp:  
             print 'end'  
             print time.time()  
             break  
     else:  
         print 'outoftime'  
         print os.kill(pro.pid, signal.SIGKILL),  
         break  
     timeout = timeout - (time.time() - while_begin)


python调用系统命令的几种形式：
os.system("command")  					#获取执行命令的返回值
os.popen(command[, mode[, bufsize]])	#获取执行命令的输出结果
commands.getstatusoutput()				#获取执行命令的返回值和输出结果
subprocess.Popen()
subprocess.call()
subporcess.run()
subprocess.getstatusoutput()

-----------------------------------------------------------------------------------------------------------------------------
python数据挖掘大赛：
统计学三大相关性系数（pearson皮尔逊、spearman斯皮尔曼、kendall肯德尔）的区别。
统计学三大相关性系数公式参考：https://blog.csdn.net/Li_318/article/details/108037562
三大相关系数分别是pearson[皮尔森]、spearman[斯皮尔曼] 和 kendall[肯德尔]
反应的都是两个变量之间变化趋势的方向以及程度，其值范围为-1到+1，0表示两个变量不相关，正值表示正相关，负值表示负相关，值越大表示相关性越强。
1.Pearson两个变量(X, Y)的皮尔森相关性系数(ρX,Y)等于它们之间的协方差cov(X,Y)除以它们各自标准差的乘积(σX, σY)。Tips

openpyxl官网：
https://openpyxl.readthedocs.io/en/stable/
python读写excel：
excel文件自身及结构的C.R.U.D操作，以及文件内容的C.U.R.D操作
Workbook对象
Worksheet对象
单元格Cell对象

pandas官网：
https://www.pypandas.cn/
https://pandas.pydata.org/
Pandas 的主要数据结构是 Series（一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。读写excel等文本数据。
Series是带标签的一维同构数组，DataFrame是带标签的，大小可变的，二维异构表格。DataFrame 是 Series 的容器，Series 则是标量的容器。
Numpy官网：NumPy这个词来源于两个单词-- Numerical和Python：
https://www.numpy.org.cn/  及其底部连接
https://numpy.org/ 及其底部连接
NumPy提供的最重要的数据结构是一个称为NumPy数组的强大对象ndarray类(n维数组)，可以是一维数组,二维数据,n维数组ndarray，随机数生成，及其他们(即向量和矩阵)的加减乘除运算。
NumPy绝对是科学Python成功的关键之一，如果你想要进入Python中的数据科学或机器学习，你就要必须学习它。
SciPy官网：
https://docs.scipy.org/doc/scipy/reference/index.html
Matplotlib官网：
https://www.matplotlib.org.cn/ 及其底部连接
http://www.matplotlib.org.cn/en/
https://matplotlib.org/stable/gallery/index
Seaborn官网： Seaborn 是基于 matplotlib (opens new window)的Python可视化库。
https://seaborn.pydata.org/
http://seaborn.pydata.org/tutorial.html

常用数据库技术，如MySQL、MongoDB

数据获取：shell脚本
数据解析到excel中：python的正则解析+逐行逐列解析存入excel中
python操作excel：openpyxl、xlrd是读excel的库，xlwt是写excel的库。
pandas只能对excel做读取操作吗？还是CRUD操作都能处理？

python脚本：数据可视化，数据分析，数据挖掘 pandas.openpyxl、numpy.scipy.scikit-learn、matplotlib.seaborn(https://seaborn.pydata.org/) pyecharts
http://www.kaggle.com/c/santander-customer-satisfaction
数据挖掘与科学算法库scikit-learn(pip3 install scikit-learn).scikit-image
应该选择scikit-learn还是pytorch还是tensorflow2.0入门？sklearn是机器学习算法包，有很多数据处理方法，目前在使用tf或者pytorch的过程中都会结合sklearn进行数据处理的，所以不冲突。
在工业界用tf的比较多，学术界基本都是pytorch，入门的话，肯定pytorch简单好用，如果只是服务端部署，建议pytorch

https://www.jb51.net/article/204984.htm
sklearn库的四大机器学习算法：分类，回归，聚类，降维。其中：
常用的回归：线性、决策树、SVM、KNN ；集成回归：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees
常用的分类：线性、决策树、SVM、KNN，朴素贝叶斯；集成分类：随机森林、Adaboost、GradientBoosting、Bagging、ExtraTrees
常用聚类：k均值（K-means）、层次聚类（Hierarchical clustering）、DBSCAN
常用降维：LinearDiscriminantAnalysis、PCA
     还包含了特征提取、数据处理和模型评估三大模块。
     同时sklearn内置了大量数据集，节省了获取和整理数据集的时间。 
使用sklearn进行机器学习的步骤一般分为：导入模块-创建数据-建立模型-训练-预测五步。
Scikit-learn 的功能包括：
分类（包括 K-Nearest Neighbors）
预处理（包括最小最大归一化）
聚类（包括 K-Means++ 和 K-Means）
回归（包括逻辑回归和线性回归）
Scikit-learn具有各种分类，回归和聚类算法，包括支持向量机，随机森林，梯度提升，k均值和DBSCAN
sklearn 中文文档：http://www.scikitlearn.com.cn/
官方文档：http://scikit-learn.org/stable/
sklearn可以实现数据预处理、分类、回归、降维、模型选择等常用的机器学习算法。
机器学习经典算法：K近邻算法、线性回归、多项式回归、逻辑回归、PCA、SVM、决策树、随机森林、集成学习、boosting ...
机器学习应用：算法推导、算法对比、算法调试、模型正则化、模型选择、模型调用、模型评价、超参调整 ...
学前必备技术：
Python3基础语法
具备高等数学，线性代数，概率论基本知识
课程对机器学习基础知识要求是0基础
机器学习基础知识：
没学会，我猜测主要原因是你没有机器学习基础知识，完全是从零开始，而大佬们知道不同模型的输入输出，知道模型的作用，只需要查查API，看看超参就能用了。
sklearn基本上是，只要你确实对算法和模型已经充分熟悉，大概了解它们实现了哪些模型，实现到了什么层面，需要用什么查查就行
了解静态计算图和动态计算图的工作原理，并跑通经典算法的官方demo

python数组的索引和切片操作(开始.结束.步长)：指定位置、连续.步长、非连续
pandas：一维数组Series和二维数组DataFrame
pandas是基于numpy的，而numpy主要解决一维、二维、n维数组ndarray的矩阵计算问题
一维数组Series也可以由map来构造，两个以上的一维数组Series可以构造一个二维数组dataFrame
一维数组和二维数组的相互转化
一维数组和二维数组的"最"值统计
一维数组和二维数组的条件过滤
一维数组和二维数组的缺失值的查看，删除及填充
一维数组和二维数组的合并contact及merge操作
dataFrame.loc(:,列) 根据标签名索引获取
dataFrame.iloc(:,列) 根据下标索引获取
pandas——相关系数函数corr()

Numpy提供最核心类型为多维数组类型（ndarray），支持大量的维度数组 与矩阵运算，Numpy 支持向量处理 ndarray 对象，提高程序运算速度。

Matplotlib 是一个Python的 2D绘图库。通过 Matplotlib，开发者可以仅需要几行代码，便可以生成绘图，直方图，功率谱，条形图，错误图，散点图等。
#导入3D包
from mpl_toolkits.mplot3d import Axes3D

-----------------------------------------------------------------------------------------------------------------------------
python打印文件名，类名，行号，调用堆栈：
# -*- coding: utf-8 -*-

import os
import sys
import platform
def printLog(log=None):
    fileNameMaxDepth=0
    methodNameMaxDepth=0
#     try:
#         for i in range(0, 100):
#             fileNameMaxDepth=i
#             f_code=sys._getframe(i).f_code
#             print("f_code= "+ str(f_code))
#     except Exception as e:
#         fileNameMaxDepth=i-2
#         print("fileName except=  i="+str(i) )
#     else:
#         pass
    
    try:
        for i in range(0, 100):
#             print("i="+str(i))
            methodNameMaxDepth=i
            methodName=sys._getframe(i).f_code.co_name
#             print("i="+str(i)+"--methodName="+methodName+"--line="+str(sys._getframe(i).f_lineno))
    except Exception as e:
#         print("methodName except=  i="+str(i)+"   --"+methodName )
        fileNameMaxDepth=i-2
        if(i>3):
            methodNameMaxDepth=i-3
        else:
            methodNameMaxDepth=i-2
    else:
        pass
        
    #当前文件名，可以通过__file__获得：print(__file__)
    fullPath=sys._getframe(fileNameMaxDepth).f_code.co_filename
    fileName=fullPath.split(os.sep)[-1]
    
    #当前函数名
    methodName=sys._getframe(methodNameMaxDepth).f_code.co_name
    
    #当前行号
    line=sys._getframe(methodNameMaxDepth).f_lineno
    print("########    "+fileName+"."+methodName+"("+str(line)+"):   "+str(log))
        
if __name__ == '__main__':
    printLog(123) 



python断点调试
http://www.ibm.com/developerworks/cn/linux/l-cn-pythondebugger/
1:在需要下断点的地方加入断点：
import pdb
pdb.set_tarce()

2:pdb常用命令介绍
查看源代码:l(list)
监视变量:p(print)
单步执行：n(next)
进入函数：s(step)
a 查看参数值
加入断点：b(break)
运行直到断点终止：c(continue)
运行直到函数返回前：r(return)
终止并退出:e(exit)
注意：pdb和GDB在很多地方有相似之处。

ipython  命令行模式下：tab键自动补全的python解释器
sublime text3 及其插件

markdown可用来做笔记，并在浏览器中打开








