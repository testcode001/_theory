jni：
基础数据类型操作可直接赋值并强转
字符串，数组，对象的创建.释放.读.写操作需调用jni的api
基础数据类型与字符串，数组，对象的嵌套
集合等复杂数据类型用数组+对象替代

JNI内存泄露处理方法：基础数据类型指针.c类型执行用ReleaseXX方法释放。java数据类型用DeleteLocalRef方法释放
在c++中new的对象，如果不返回java层，必须用release掉，否则内存泄露。包括NewStringUTF，NewObject。如果返回java层不必release，java会自己回收。
JNI 支持3中不透明的引用：局部引用、全局引用和弱全局引用。
https://blog.csdn.net/huguohu2006/article/details/7397055
总体原则：释放所有对object的引用
1.FindClass例如，
jclass ref= (env)->FindClass("java/lang/String");
env->DeleteLocalRef(ref);
2.NewString/ NewStringUTF/NewObject/NewByteArray例如，
jstring     (*NewString)(JNIEnv*, const jchar*, jsize);   
const jchar* (*GetStringChars)(JNIEnv*, jstring, jboolean*);     void        (*ReleaseStringChars)(JNIEnv*, jstring, const jchar*);
jstring     (*NewStringUTF)(JNIEnv*, const char*);   
const char* (*GetStringUTFChars)(JNIEnv*, jstring, jboolean*);     void        (*ReleaseStringUTFChars)(JNIEnv*, jstring, const char*);
env->DeleteLocalRef(ref);
3.GetObjectField/GetObjectClass/GetObjectArrayElement
jclass ref = env->GetObjectClass(robj);
env->DeleteLocalRef(ref); 
4.GetByteArrayElements和GetStringUTFChars
jbyte* array= (*env)->GetByteArrayElements(env,jarray,&isCopy);
(*env)->ReleaseByteArrayElements(env,jarray,array,0);
const char* input =(*env)->GetStringUTFChars(env,jinput, &isCopy);
(*env)->ReleaseStringUTFChars(env,jinput,input);
5.NewGlobalRef/DeleteGlobalRef
jobject     (*NewGlobalRef)(JNIEnv*, jobject);
void        (*DeleteGlobalRef)(JNIEnv*, jobject);
例如，
jobject ref= env->NewGlobalRef(customObj);
env->DeleteGlobalRef(customObj);
https://www.iteye.com/blog/amazontzy-1962367有必要分析一下 ReleaseStringUTF 这个函数了，先看一下该函数的解释：
在调用 GetStringUTFChars 函数从 JVM 内部获取一个字符串之后，JVM 内部会分配一块新的内存，用于存储源字符串的拷贝，以便本地代码访问和修改。
即然有内存分配，用完之后马上释放是一个编程的好习惯。通过调用ReleaseStringUTFChars 函数通知 JVM 这块内存已经不使用了，你可以清除了。
注意：这两个函数是配对使用的，用了 GetXXX 就必须调用 ReleaseXXX，而且这两个函数的命名也有规律，除了前面的 Get 和 Release 之外，后面的都一样。
一般都是在最后的return之前调用 ReleaseStringUTF 方法。

local reference table overflow (max=512)
https://blog.csdn.net/xpz445094213/article/details/46633889
https://blog.csdn.net/win2k3net/article/details/6613440
https://blog.csdn.net/xyang81/article/details/44873769
GetMethodID中sig参数对函数的签名(jdk命令javap)：
https://blog.csdn.net/u010126792/article/details/82348438
https://blog.csdn.net/buding_code/article/details/53117220?utm_source=blogxgwz1
https://www.jianshu.com/p/b428a55815cd
c和java字符串互转：
jstring str = env->NewStringUTF("eascs"); 		c++转java字符串
const char *s = env->GetStringUTFChars(str, 0); java转c++字符串
https://blog.csdn.net/zhoudailiang/article/details/50471483
jni和c/c++多线程的处理
https://blog.csdn.net/popop123/article/details/1511180
https://www.cnblogs.com/bulengjianghu/p/android_JNI_nativeThread.html

java基础数据类型和byte相互转换：即左移<<，右移>>的位运算
https://www.cnblogs.com/wbcqz/p/9236570.html
java的byte和Bit之间的转换：即左移<<，右移>>的位运算
http://www.javacui.com/Theory/268.html
NDK:
https://blog.csdn.net/afei__/article/details/81290711


jni层崩溃并捕获：
jthrowable ex = env->ExceptionOccurred();
if(ex){
    env->ExceptionDescribe();
    env->ExceptionClear();
}
jni层向java层抛异常：
env->ThrowNew(jclass, "exception msg");

so库崩溃分析：
libc    : Fatal signal 11 (SIGSEGV), code 1, fault addr 0x0 in tid 5909 (NativeApp), pid 5884 (ayback.handheld)
ndk-stack加入系统环境变量
进入工程目录下：adb logcat | ndk-stack -sym obj/local/armeabi
arm-Linux-gnueabi-addr2line 0002e180 -e camera.meson6.so
objdump

ndk-stack有两个选项：
选项	说明
-sym	指定debug版本库的位置
-dump	指定含有crash信息的文件
1.根据logcat信息“翻译”jni的crash信息，适合发布之前的调试使用
$adb logcat | $NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi
2.根据crash文件“翻译”jni的crash信息
$ NDK/ndk-stack -sym $PROJECT_PATH/obj/local/armeabi -dump foo.txt
为了方便使用，可以写两个shell函数：默认arch为【armeabi-v7a】：
ndk_stack_logcat()
{
    projeck=./
    if [ $# -eq 1 -a -d "$1" ]; then
        projeck=$1/
    fi
    adb logcat | $NDK/ndk-stack -sym $projeck/obj/local/armeabi-v7a
}
ndk_stack_file()
{
    $NDK/ndk-stack -sym $1/obj/local/armeabi-v7a -dump $2
}

android jni用vscode或者vimide编写
-------------------------------------------------------------------------------------------------------------
jni中c语言的值传递和址传递。
c语言对象.指针赋值前须先malloc申请内存再赋值，最后free释放内存。

c语言指针在使用前一定要初始化或动态申请内存
http://c.biancheng.net/view/228.html
结构体指针的调用
http://c.biancheng.net/view/2033.html
C语言动态内存分配详解
http://c.biancheng.net/view/223.html
cppreference：
https://en.cppreference.com/w/Main_Page


XX.h头文件中的下列宏定义用来标明当前头文件已定义过，避免重复定义和引用。
在.h文件中，通过#define定义一个名字，并且通过条件编译#ifndef...#endif使得编译器可以根据这个名字是否被定义：避免类被多次定义
.h文件只是在预编译的时候完整拷贝其内容
#include的作用是在预编译的时候把它后面所写的那个文件的内容，完完整整地、一字不改地包含到当前的文件中来，别无其他。
.h函数的声明：没有花括号{}方法体
函数的实现：有花括号{}方法体
函数四要素：名字，形参，返回值，花括号{...}方法体。
复杂工程容易出现类名重复时，需要定义包名即自定义命名空间 namespace A{ class A1{...} }
#ifndef TEST01_H
#define TEST01_H
...
#endif
	
#ifdef
#else
#endif
.cpp文件: 所有系统标准库stl的类前必须加限定符std::, 或者在最外层使用using namespace std; 声明。
XX.h头文件中写类的定义和属性.方法的声明，XX.cpp文件中只写类的方法实现，用类名限定符修饰classA::
.cpp文件中写实现方法.或调用类的方法或属性时，要明确方法或属性的全路径，即要用命名空间namespace限定符修饰spaceA::+类名限定符修饰spaceA::classA::。 using namespace std; using namespace cv;
#include <iostream> 
namespace A{...} #自定义命令空间花括号语句块
using namespace A #即包名+类名
using namespace std; //使用c++命名空间。c语言默认都是全局作用域。C++ STL标准模板库13个头文件(算法3.容器7.迭代器1.内存分配器1)，这些都在std命名空间中定义using namespace std; : 
#include"../include/xx.h"   	与java相比，c++不方便的一点是所有的头文件依赖都要手动导入即#include"../include/xx.h"
#include包含.h头文件时，双引号"xx.h"表示先从当前目录查找，找不到再从系统目录查找，尖角号<xx.h>表示只从系统目录查找。 
只有.c/.cpp文件参与编译、链接。


一个符号在整个程序中可以被声明多次，但必须要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？就会编译报错
.h头文件中只能存在变量或者函数的声明，而不要放定义。但是，这个规则是有三个例外的：类class的定义、全局的const对象、内联函数（inline）的定义
类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。
即只能在头文件中写形如：extern int a;和void f();的句子，这些才是声明。不能写上int a;或者void f() {}这样定义的句子
http://blog.csdn.net/xupan_jsj/article/details/7855090
在.h头文件中可以写函数的实现(但不建议)，即使实现了函数且被重复包含，也是不会出错的有两种语法：
一个是模版，无论是写在头文件还是cpp文件中，模版需要定义和实现必须写在一起．
第二种是内联inline函数．即利用下面语句定义的函数．inline function_type function_name(){...}

c++推荐使用单继承，而多继承时应使用virtual继承以避免二义性(调用函数不知道调用哪个基类的成员变量和函数、节省内存空间)
virtual虚继承和普通继承

公有继承，子类都重写了父类的虚函数和普通函数，虚函数和普通函数的区别是什么？ 即普通函数的调用取决于当前指针是父类还是子类
在父类引用指向子类对象时，调用普通函数时是调用父类的，而调用虚函数时是调用子类的。
在子类引用指向子类对象时，调用普通函数时是调用子类的，调用虚函数时也是调用子类的。
父类引用指向子类对象时，调用父类的virtual run()方法时，须加父类作用域操作符pointer->ParentClass::run();

final函数不能被重写
虚函数：子类可实现也可不实现，父类提供公共操作即默认操作，用来父类引用指向子类对象时实现多态性。
纯虚函数：相当于java中的接口，子类必须实现,父类可实现可不实现。含有纯虚函数的类不能实例化。virtual void print(...)=0，声明函数时添加"=0"
关于虚函数，在多态当中，一定要将基类的析构函数设置为虚函数并将其实现，只有这样，才能够达到按对象构造的逆序来析构对象；否则，析构的时候，只会析构基类的那一部分，那么派生类那一部分就无法成功析构了。
重写overrie：子类重新定义父类中有相同名称和参数的virtual虚函数
重定义即隐藏redefine：子类重新定义父类中有相同名称的非虚函数.即普通函数 (参数可同.可不同)
virtual函数：virtual void foo();
纯虚函数: virtual void foo()=0;
只要含有纯虚函数的类是抽象类，不能被实例化。虚函数的调用是在运行时确定的。
virtual函数是基类中的接口，是派生类中的实现，基类的析构函数~必须是virtual的
virtual函数: 先调用自身的，在调用父类的。没有virtual则直接调用父类的
virtual函数用于父类指针指向子类对象时的多态的实现

c++构造函数、~析构函数
c++静态属性成员初始化：只能在.cpp文件的方法的外边初始化，初始化格式为：类型 类名::变量名 = 变量值
c++创建对象的两种方式及区别：new创建的是指针，不用new创建的是普通变量，即类名 变量名，有等号=赋值和括号()赋值两种初始化机制。
不用new，创建的是普通类实例，写法：括号赋值：StudentA s02("lisi"); 或者 等号赋值：StudentA s01 = StudentA("lisi"); 即构造函数初始化机制中，有等号=赋值和括号()赋值两种赋值机制。
不用new(即直接类名 变量名),从栈上创建：即函数内的局部变量，自动分配与回收，效率高，但是分配的内存量有限。此种创建方式，使用完后不需要手动释放，该类析构函数会自动执行
用new，从堆上创建：由程序员控制，malloc、new，free、delete。而new申请的对象，则只有调用到delete时再会执行析构函数。
用new，创建的是指针(new的返回值是一个指针)，c++用指针实现地传递。new 和delete一定要成对使用，手动分配和释放内存。
this指代当前指针
指针初始化,避免野指针：pointer=NULL;pointer=new Object(),指针释放：delete pointer;pointer=NULL;delete指针后，一定要将该指针赋值为0，避免野指针。
若同一指针delete两次，程序可能会崩溃
https://www.cnblogs.com/zhousong918/p/10489366.html
C++中慎用malloc：
malloc是C语言中常用的内存申请方式，C++也支持，但是对于STL来说却不兼容，取而代之的是new。
情景：曾写过一个C与C++混合的项目，内存申请使用了malloc，同时使用了std::vector，程序中两种结构之间进行了数据流通。但是程序运行时，部分指针的值被“莫名修改”，导致运行出错。
使用gdb调试，观察相关变量的内存地址，发现std::vector竟然可以覆盖修改malloc此前申请的内存区域。明显std::vector不识别malloc申请的内存，将这部分内存标记为未使用状态。
解决方法：将所有malloc改为new，解决问题。
C++构造函数初始化列表：A(int x,int y) : propertyNameA(x),propertyNameB(y){...}  //充当部分函数体，对属性成员进行初始化
https://www.cnblogs.com/wkfvawl/p/10902220.html
https://www.runoob.com/w3cnote/cpp-construct-function-initial-list.html
在子类构造函数实现(.cpp文件)中的后边，加上一个冒号(:)，然后加上父类的带参构造函数，这就是父类构造函数的显式调用。如：
son():father(propertyName){...} //显示调用父类的构造函数
C++ 构造函数后加冒号：
有些数据需要分配内存空间时才进行赋值初始化，或者分配空间后函数体执行前进行数据初始化，或者构造函数执行后，函数体执行前进行数据初始化，这就是C++的一种赋值特性。
C++构造函数后面的冒号具有初始化表达式的作用，其后面可以说是跟着赋值语句。
初始化const成员、初始化引用成员、调用基类或者成员类的构造函数时可以使用
C++声明为explicit的构造函数不能在隐式转换中使用。
c++的类如果没有实现构造函数,系统会默认加上一个无参数的构造函数。


c++引用与指针的区别：
引用.指针.普通变量可以相互转化。指针.引用才能实现址传递，普通变量不能。
C++语言中，函数的参数和返回值的传递方式有三种：值传递(普通变量)、指针传递和引用传递。引用即普通变量别名。
指针用操作符‘*’和‘->’，引用的调用方式类似于普通变量，用点‘.’调用。
引用使用时无需解引用（*），指针需要解引用；
const修饰的引用让引用拥有只读属性，如const Type& name = var; 引用name只读
引用不能为空，必须进行初始化，指针可以为空；函数的形参引用不需要进行初始化。
一旦引用被初始化，就不能改变引用的关系(可修改变量值，但不能改变引用关系)（指针则可以随时改变所指的对象）
引用本质是限制版的指针，不允许空引用和二次赋值，但可以修改引用的值。
引用变量是指针变量和普通变量的结合。
指针指向一块内存，它的内容是所指内存的地址；引用是某块内存的别名。
以下程序中，n 是m 的一个引用（reference），m是被引用物（referent）。
    int m；
    int &n = m；  
	n 相当于m 的别名（绰号），对n 的任何操作就是对m 的操作。
以下示例程序中，k 被初始化为i 的引用。语句k = j 并不能将k 修改成为j 的引用，只是把k 的值改变成为6.由于k 是i 的引用，所以i 的值也变成了6.
    int i = 5；
    int j = 6；
    int &k = i；
    k = j； // k 和i 的值都变成了6；
“引用传递”的性质像“指针传递”，而书写方式象“值传递”。实际上“引用”可以做的任何事情“指针”也都能够做，为什么还要“引用”这东西？
答案是“用适当的工具做恰如其分的工作”。如果总是指向一个对象并且一旦指向一个对象后就不会改变指向，那么你应该使用引用。引用的主要功能是传递函数的参数和返回值。
指针能够毫无约束地操作内存中的如何东西，尽管指针功能强大，但是非常危险。如果的确只需要借用一下某个对象的“别名”，那么就用“引用”，而不要用“指针”，以免发生意外。
在以下情况下你应该使用指针，一是你考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空），二是你需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）。
https://blog.csdn.net/qq_34243930/article/details/81638852
https://www.cnblogs.com/codingmengmeng/p/5865510.html
https://www.cnblogs.com/haoyul/p/7282613.htm
C++中的引用旨在大多数的情况下代替指针。
功能性：可以满足多数需要使用指针的场合。
安全性：可以避开由于指针操作不当而带来的内存错误。
操作性：简单易用，又不失功能强大。
引用在C++中的内部实现是一个指针常量，下面的写法是等价的。
C++ 编译器在编译过程中用指针常量作为引用的内部实现，因此引用所占用的空间大小与指针相同。
C++ const 和 constexpr 的区别：
constexpr表示这玩意儿在编译期就可以算出来（前提是为了算出它所依赖的东西也是在编译期可以算出来的）。
而const只保证了运行时不直接被修改（但这个东西仍然可能是个动态变量）
c++在函数后加const的意义：
我们定义的 类的成员函数中，常常有一些成员函数不改变类的数据成员，也就是说，这些函数是"只读"函数，而有一些函数要修改类数据成员的值。
如果把不改变数据成员的函数都加上const关键字进行标识，显然，可提高程序的可读性。其实，它还能提高程序的可靠性，已定义成const的成员函数，一旦企图修改数据成员的值，则编译器按错误处理。
const成员函数和const对象 实际上，const成员函数还有另外一项作用，即常量对象相关。对于内置的数据类型，我们可以定义它们的常量，用户自定义的类也一样，可以定义它们的常量对象。
c++函数后加const的三种情况：
1、  非静态成员函数后面加const（如果加到非成员函数或静态成员后面会产生编译错误）
2、  表示成员函数隐含传入的this指针为const指针，决定了在该成员函数中，任意修改它所在的类的成员的操作都是不允许的（因为隐含了对this指针的const引用），唯一的例外是对于mutable修饰的成员。
3 、（1）加了const的成员函数可以被非const对象和const对象调用
    （2）不加const的成员函数只能被非const对象调用

http://c.biancheng.net/cpp/html/3248.html
c语言函数指针的定义形式为：将函数声明的的函数名用(*)括起来(*函数名)即可。(把指针函数的函数名和星号*括起来就是函数指针)
returnedType (*pointerName)(param list);
注意( )的优先级高于*，第一个括号不能省略，如果写作returnType *pointerName(param list);就成了指针函数的函数原型，它表明函数的返回值类型为returnType *。
参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。
函数指针：
正向调用：解耦，实现调用者和实现者的分离
反向调用即回调函数
二、函数指针变量与回调函数
函数指针与回调函数：函数指针类型、函数指针变量
typedef定义类型别名
函数指针类型(typedef)	函数指针变量
C++不支持const函数指针，我们只能定义非const函数指针变量
函数如下
void foo(int a, int b)
{
    cout << a + b << endl;
}
1、直接定义函数指针
void (*pf)(int, int);   // 定义函数指针变量pf
     pf = foo;               // 赋值使其指向函数foo --- (1)
     pf = &foo;              // 赋值使其指向函数foo --- (2)
                             // (1)与(2)均ok
 
     pf(6, 7);               // 通过函数指针调用函数:输出13 --- (3)
     (*pf)(6, 7);            // 通过函数指针调用函数:输出13 --- (4)
                             // (3)与(4)均ok
2、利用类型别名定义
typedef void (*FunPtr)(int, int);　　// 定义函数指针类型
FunPtr pf;              // 定义函数指针变量pf

     pf = foo;               // 赋值使其指向函数foo --- (1)
     pf = &foo;              // 赋值使其指向函数foo --- (2)
                             // (1)与(2)均ok
 
     pf(6, 7);               // 通过函数指针调用函数:输出13 --- (3)
     (*pf)(6, 7);            // 通过函数指针调用函数:输出13 --- (4)
                             // (3)与(4)均ok


指针常量 char* const pStr = "123";(pStr值不可修改，但*pStr可修改)
指向常量的指针 const char* pStr = "123";(pStr可修改，但*pStr不可修改)
指针.数组：是一个数组，数组中的每个元素都是指针。
数组.指针：是一个指针，指向数组的指针
指针.函数：是一个函数，函数的返回值是是一个指针。
函数.指针：是一个指针，指向函数的指针。函数指针作为参数，用来实现回调函数。
字符数组或者字符指针以'\0'结尾。
一级指针、二级指针，变量是0级指针
字符串即字符数组、字符指针
一维数组即一级指针，二维数组即二级指针
"\" makefile、shell、c++中用于连接本行和下一行。

c：
定义：int (*pFunction)(float,char,char)=NULL;
赋值：pFunction=&func2;
调用：(*pFunction)(10.0,’a’,’b’);
c++:
定义：int (MyClass::*pMemberFunction)(float,char,char)=NULL;
赋值：pMemberFunction= &mc.func1;  //必须要加取地址符号
调用：(mc.*pMemberFunction)(10.0,’a’,’b’);
指针函数：是一个函数，返回值类型是指针。
函数的返回值类型是一个函数指针：
float (* func(char args) ) (float ,float)
其函数名为func，其参数的个数为1个char args；
其返回变量类型为：float(*)(float,float)，是一个函数指针。

*和[]对指针降级即解引用，操作指针所指向的地址的值
http://blog.csdn.net/sruru/article/details/7916296
http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html
不管怎么说， 函数指针.回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。

c++操作符：
*放在等号左边是定义指针，放在等号右边是解引用.取指针数据。
&放在等号左边是定义引用，放在等号右边是取地址符。
等号左边有指针，引用.解引用(*pointer)，变量; 等号右边是对象 
c++调用包含的层级关系：.h头文件、命名空间namespace NameA、类名、函数名.属性名
c++双冒号::调用要么是命名空间namespace NameA{...}调用，要么是类名::调用，即类名和自定义命名空间都可以使用双冒号::限定符
指针调用用->，引用或者实例对象调用用点. ，命名空间和类名的静态方法或属性调用::
定义类：	: public 类名, : private 类名(多继承.实现，c++中没有定义接口/抽象类的关键字)
~用于定义析构函数，类继承用:
方法实现：	返回值类型 类名::方法名()

c++的4种数据类型转换：语法 Type b = static_cast<Type>(a);
去const属性用const_cast
基本类型转换用static_cast
多态类之间的类型转换用dynamic_cast
不同类型的指针类型转换用reinterpret_cast
C++强制类型转换: static_cast, reinterpret_cast, const_cast 和 dynamic_cast.
1.const_cast 用来移除 const,这个没什么好说的.
2.dynamic_cast 需要 RTTI 支持, 主要用于把基类指针转换为派生类指针.这里的基类指针其实是指向一个派生类实例,只是类型为基类.
示例:
// 前提假设: class B 由 class A 派生
A *ptrA = new class B;
B *ptrB = dynamic_cast<B*>(ptrA);
派生类指针到基类指针用隐式类型转换(直接赋值)或者用 static_cast. 
基类指针到派生类指针用 dynamic_cast (运行期检查)或者 static_cast (运行期不检查,由程序员保证正确性).
3.4.本文主要谈谈 static_cast 和 reinterpret_cast 的用法和区别: static_cast 运算符完成*相关类型*之间的转换. 而 reinterpret_cast 处理*互不相关的类型*之间的转换.
比如我写代码的时候经常这样做: new 一个 struct,然后把指针返回给外部函数作为一个"句柄",我不希望外部函数知道这是一个指针,只需要外部函数在调用相关函数时把这个"句柄"重新传回来.这时,就可以把指针转换为一个 int 型返回. 这是 reinterpret_cast 存在的绝佳理由.


宏定义：
#define a 3 	//c++宏定义整个文件都可以使用a， define没有作用域概念
#define 宏名(参数) 宏变量.宏函数   即字符串替换  避免函数调用时进栈.出栈的性能影响。但不是类型安全的。宏函数的每个参数及整个宏体都最好加一个括号。
#undef 宏名
c++宏定义#define即纯字符串替换，最好用小括号()确定运算顺序 #define 
运算符重载关键字operator：operator和运算符一起使用，表示一个运算符重载函数(本质就是一个函数)，在理解时可将operator和运算符（如：operator=）视为一个函数名
在类体中声明(定义)需要重载的操作符，声明方式跟普通的成员函数一样，只不过操作符重载函数的名字是“operator 和紧跟其后的一个C++的操作符”，（如：operator=）。
<< >> 这两个运算符只能用友元函数实现运算符重载，其他运算符重载用类的成员函数实现。
https://blog.csdn.net/liitdar/article/details/80654324
C++的bool类型只有true（非0）和false（0）两个值。C++编译器会将非0值转换为true，0值转换为false。

C++11使用using定义别名(替代typedef)：using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法=，把现有的类型（type-id）赋给新类型：
template <typename T>
using sp = std::shared_ptr<T>;
http://c.biancheng.net/view/3730.html
typedef void* HANDLE，如何理解呢？
对于void* 神通广大，因为它作为函数参数or函数返回值，能够接受任何类型的指针；也就是来者不拒，是指针就接受。但应用的时候，应该注意，void* 必须指向具体的类型；例如：
void * HappyPt;
int* pi=static_cast<int*>HappyPt;; //注意喽，在这里具体到了int*哦！
用typedef来定义与平台无关的类型。
https://blog.csdn.net/Andrewniu/article/details/80566324
typedef int a[10];	//把a声明为具有10个int元素的数组的类型别名
typedef void (*p)(void); 	//把p声明为一种函数指针的类型别名
虽然在功能上，typedef可以看作一个跟int PARA分离的动作，但语法上typedef属于存储类声明说明符，因此严格来说，typedef int PARA整个是一个完整的声明。
比如原函数是   void   func(void); 那么定义的函数指针类型就是typedef   void   (*Fun)(void); 
然后用此类型生成一个指向函数的指针：Fun  func1; 当func1获取函数地址之后，那么你就可以向调用原函数那样来使用这个函数指针：   func1(void);

编译检查语法错误，链接检查函数或变量的定义是否存在
https://blog.csdn.net/bleedingfight/article/details/80906556
.a和.so文件
https://www.cnblogs.com/luntai/p/5291354.html

C++关键字：
#pragma指示编译器完成一些特定的动作
typedef 定义类型别名
const	定义常量
template
extern可以置于变量或者函数前
在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？
extern “C” 则告诉编译器在编译fun这个函数名时按着C的规则去翻译
extern "C++" {代码块}
malloc free//c
new delete//c++
c++程序中使用c代码：extern "C"{}关键字代码块：表示使用的是c代码
C++11 新增关键字auto
for (auto iter : vertorContainer) 
{
    cout << iter << ",";
}
for(auto it=vertorContainer.begin(); it!= vertorContainer.end(); it++)
{
    cout << *it << ",";
}


搜索：c语言32个关键字：
32位系统内存最大寻址范围0xffffffff，支持最大内存为2的32次方byte，即4GB
auto 局部变量（自动储存）
break无条件退出程序最内层循环
case switch语句中选择项
char单字节整型数据
const定义不可更改的常量值
continue中断本次循环，并转向下一次循环
default switch语句中的默认选择项
do 用于构成do.....while循环语句
double定义双精度浮点型数据
else构成if.....else选择程序结构
enum枚举extern在其它程序模块中说明了全局变量
float定义单精度浮点型数据
for构成for循环语句
goto构成goto转移结构
if构成if....else选择结构
int基本整型数据
long长整型数据
registerCPU内部寄存的变量
return用于返回函数的返回值
short短整型数据
signed有符号数
sizoef计算表达式或数据类型的占用字节数
static定义静态变量
struct定义结构类型数据
switch构成switch选择结构
typedef重新定义数据类型
union联合类型数据
unsigned定义无符号数据
void定义无类型数据
volatile该变量在程序中执行中可被隐含地改变
while用于构成do...while或while循环结构
然后你在记住9种控制结构就OK。
goto语句:无条件转向;
if语句:判断语句;
while循环语句;
do-while语句:先执行循环体,然后判断循环条件是否成立. 之后继续循环;
for语句:循环,可替代while语句; 只是用法不同;
break语句跳出本层的循环;(只跳出包含此语句的循环)
continue语句:继续(一般放到循环语句里,不在执行它下面的语句,直接跳到判断语句例:
for语句,就直接跳到第二个分号处,
while语句,就直接跳到while()的括号里;
switch语句:多相选择;
return语句:返回;

C标准库：
assert.h
ctype.h
errno.h
float.h
limits.h
locale.h
math.h
setjmp.h
signal.h
stdarg.h
stddef.h
stdio.h
stdlib.h
string.h
time.h

C++父类中的虚函数用以实现“运行时多态”，即父类引用指向子类对象
在虚函数的声明后边添加=0;即变为纯虚函数。C++父类中的纯虚函数用以实现抽象类，即只有声明，没有实现
虚函数：virtual 函数返回类型 函数名(参数表) { 函数体 }
纯虚函数：virtual 函数返回类型 函数名(参数表)=0
使用虚函数，我们可以灵活的进行动态绑定，当然是以一定的开销为代价。如果父类的函数（方法）根本没有必要或者无法实现，完全要依赖子类去实现的话，可以把此函数（方法）设为virtual 函数名=0 ，例如：virtual void fun() = 0，我们把这样的函数（方法）称为纯虚函数。如果一个类包含了纯虚函数，称此类为抽象类。
总结：如果一个子类想要重写父类的方法，那么父类的这个成员方法必须是virtual的，也就是这个方法必须是虚函数。
c++虚函数
1.定义：在某基类中声明为 virtual 并在一个或多个派生类中被重新定 义的成员函数 [1]
2.语法：virtual 函数返回类型 函数名（参数表） { 函数体 }
3.用途：实现多态性，通过指向派生类的基类指针，访问派生类中同名覆盖成员函数，也就是允许子类override父类同名方法。
虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型（也就是完全相同的方法，不能只是函数名相同。）。以实现统一的接口，不同的定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。
当程序发现虚函数名前的关键字virtual后，会自动将其作为动态联编处理，即在程序运行时动态地选择合适的成员函数。虚函数是C++多态的一种表现。
动态联编规定，只能通过指向基类的指针或基类对象的引用来调用虚函数，其格式：
1.指向基类的指针变量名->虚函数名（实参表）
2.基类对象的引用名.虚函数名（实参表）
在C++语言中，如果某个类有虚函数，那么大多数编译器都会自动的为其对象维护一个隐藏的“虚指针（virtul-pointer）”，虚指针指向一个全局“虚表（virtual-table）”。
虚函数表是属于类的，而不是对象的。也就是说，即使有成千上万个A对象，虚表也仅有一个，这些对象共用一个类虚表。编译器会自动的为每个对象创建一个隐藏的“虚指针”__vptr，它指向类 A 的虚表，
虚函数表中存放若干函数指针，这些函数指针指向类中的虚函数。
虚函数机制的空间开销是微乎其微的，事实上，每一个对象只需要一个额外的“虚指针”__vptr就能够调用类的虚函数。
同样的，时间开销也很小：相比于常规函数的调用，虚函数的调用只不过多出了额外的两个步骤：
1.获取虚表指针
2.得到虚表从虚表中取出虚函数的地址
非虚函数是静态解析的，即在编译时即可根据指针指向的对象确定是否被调用。
虚函数是动态解析的，也即在程序被编译后，运行时才根据对象的类型，而不是指向对象的指针类型决定其是否被调用，这就是所谓的“动态绑定”。
https://baijiahao.baidu.com/s?id=1653132502323288772&wfr=spider&for=pc
c++基础：多态.虚函数，纯虚函数.抽象类，多继承。template函数模板.类模板即c++的泛型编程。
https://pan.baidu.com/s/1c049lk#list/path=%2F
virtual虚函数即多态：父类virtual虚函数在子类中被重写后，该函数即可实现多态特性
纯虚函数即抽象类：virtual 返回值类型 函数名(形参)=0; 即只有函数声明，没有函数体
base类virtual虚析构函数作用：即通过delete父类指针释放子类资源[调用子类析构函数]
virtual虚继承只能解决部分c++多继承的二义性问题，特殊情况须指明调用的全路径
纯虚函数即抽象类的多继承没有二义性问题
vptr指针与虚函数表
父类指针和子类指针执行++的步长不一样
在java中，所有方法默认就是虚拟的，只要方法不是声明为final类型的，那么肯定就是虚函数，不用为方法显示声明为virtual。
在<core java2 :volum I>中提到："In Java, you do not need to declare a method as virtual. Dynamic binding is the default behavior. If you do not want a method to be virtual, you tag it as final"。
所以我们发现，在java中，子类可以重写(override)父类的方法，而父类没有声明virtual。

虚继承--解决c++多继承.菱形继承的二义性和数据冗余的问题
虚继承语法：     class 派生类名：virtual 访问控制 基类名1，virtual 访问控制 基类名2
普通多继承语法： class 派生类名：访问控制 基类名1，访问控制 基类名2
https://www.cnblogs.com/yjd_hycf_space/p/6721179.html
https://www.cnblogs.com/long5683/p/11402194.html
http://c.biancheng.net/view/2280.html
c++普通继承和虚继承virtual public的区别？
https://blog.csdn.net/weixin_30617737/article/details/101852090
http://c.biancheng.net/view/2280.html
对于类外部来说，protected和private类似，而对于派生类来说，protected与public类似。
只有在派生的时候，private和protected关键字才能体现出差异：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员
派生继承权限补充下：基类权限 	public protected private
public继承： 		public protected private
protected继承：		protected protected private
private继承： 		private private private
在C++中用class定义的类中,其成员的默认存取权限是private; 在C++中用struct定义的结构体中,其成员的默认存取权限是public。即class默认private.struct默认public
C++三种权限继承public/protected/private：举例protected说明：
1.三种属性能力的强弱：public<protected<private
2.保护继承相当于先将从父类继承的所用成员都放在子类的protected部分：
3.然后和公有继承一样，再根据父类修饰符三种属性能力的强弱决定成员的属性在子类中究竟是public、protected还是private
c++中类和结构体的唯一区别是：默认状态下，类中的成员默认是私有的，结构体中的成员默认是公有的。(把struct当成class即可)
c++中的结构体和c中的结构体的区别：c++中的结构体引入了成员函数，继承，访问控制等面向对象的特性。c中的空结构体的大小为0，c++中的空结构体和空类一样，大小是1
c++中空类的大小是1的原因：空类可以实例化成不同的对象，不同的对象在内存中的地址不同，所以隐含地加入一个字节来标识不同的对象。
https://www.nowcoder.com/questionTerminal/fb7417c3c3d247979bb5ae6bee4604f6
假如在类A中使用了类B，在沒有包含类B时，编译时提示找不到类B响应的方法。解决办法就是包含对应的类，如直接包含class String8; 结构体也可以这样包含。
https://blog.csdn.net/laozhuxinlu/article/details/51346376
c++形参可以有默认值：
1.带有默认值的形参必须从参数表的最右侧开始连续的不间断的列出。
2.如果分别给出了函数声明和函数定义，形参默认值只能出现在函数声明中。 

c++模板函数.模板类(即泛型编程.类型参数化)：
templete <typename T1, typename T2...> 或者 templete <class T1, class T2...>
...函数实现/类定义...(函数或者类中可使用泛型类型T1，T2)
模板函数/模板类调用时,类型必须具体化<Type1,Type2...>。如functionName<Type1,Type2...>(params)
模版无论是写在.h头文件还是cpp文件中，其定义和实现必须写在一起，模板类文件后缀一般为.hpp，其他文件引用模板类时必须include".hpp"实现文件，而不是".h"声明文件。
在template语句与函数模板定义语句<返回类型>之间不允许有别的语句。如下面的声明是错误的：
template<class T>
int I;
T min(T x,T y)
{
   函数体
}
模板函数.模板类的参数都可以有默认值。
当所有模板参数都有默认值时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<>来实例化。
stl标准模板库(算法3.容器7.迭代器1.内存分配器1)：是一套功能强大的C++模板类。boost？
容器提供迭代器begin()和end()，算法使用迭代器；常见的一些迭代器类型：iterator、reverse_iterator(反向迭代器)、只读迭代器const_iterator和const_reverse_iterator,
vector<int>::iterator itor = vec.begin(); itor++;
http://c.biancheng.net/stl/
https://blog.csdn.net/u010183728/article/details/81913729
https://blog.csdn.net/piaoxuezhong/article/details/54348787
http://www.cplusplus.com/reference/bitset/bitset/?kw=bitset
C++ STL13个头文件，这些在std命名空间中定义using namespace std; : (<array><string>除外)
<array><vector>(数组)<deque>(双向数组) <list>(双向链表)<set>(红黑树)<map> <iterator> <queue><stack>  <algorithm><numeric><functional>(作用即函数指针) <memory><utility> (<iostream> <stdio.h>)
<bitset>并不是标准的STL容器。bitset并没有iterator，也没有begin()和end()。<bitset>的大小是不可变的，它的大小由模板参数N确定，N是整数常量。
这样设计的理由是bitset中的元素就是bit位，不能容纳任何其他元素，并且bitset中bit位有特定的操作都需要实现，例如与、或、非以及异或。因此，不能够也不需要把bitset设计成STL标准容器。
按照C++标准库的规定，所有(标准头文件)都不再有扩展名。以 <vector> 为例，此为无扩展名的形式，而 <vector.h> 为有扩展名的形式。
迭代器本身就是一个指针，使用时需要解引用*iterator
C++容器大致分为序列式容器和关联式容器。序列式容器包括 array、vector、list、deque 和 forward_list。4种关联式容器分别为 map、set、multimap、multiset
关联式容器存储的元素，默认会根据各元素的键值的大小做升序排序，关联式容器所具备的这些特性，归咎于该类型容器底层选用了「红黑树」这种数据结构来组织和存储各个键值对。
C++ 11还新增了4种哈希容器，即 unordered_map、unordered_multimap 以及 unordered_set、unordered_multiset，但底层采用的是哈希表，而不是红黑树。
http://c.biancheng.net/view/vip_3433.html
class中重写仿函数后，可用set容器实现复杂数据类型的自动排序
如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。
http://c.biancheng.net/view/6593.html
https://www.runoob.com/cplusplus/cpp-stl-tutorial.html
站在编译器的角度思考问题：模板函数.模板类是编译器通过两次编译实现具体类型代码的自动编写
数据结构
http://c.biancheng.net/view/3431.html
http://c.biancheng.net/view/vip_3433.html

.inl文件是内联函数的源文件  .hpp文件是模板函数，模板类的源文件
内联函数通常在c++头文件中实现，但有内联函数较多的时候，会将这部分具体定义的代码添加到.inl文件中，然后在.h头文件的末尾将其引入#include "xx.inl"
由此也可以看到inl文件的例外一个用法的影子——模板函数、模板类的定义代码的存放。
对于比较大的工程来说，出于管理方面的考虑，模板函数、模板类的声明部分一般存放在一个或少数几个文件中，而将其定义部分存放在inl文件中，然后在相应的头文件中包含进来。
内联函数定义：在返回值类型前面加上inline关键字。
内联函数和普通函数的区别在于：当编译器处理调用内联函数的语句时，不会将该语句编译成函数调用的指令，而是直接将整个函数体的代码插人调用语句处，就像整个函数体在调用处被重写了一遍一样。
有了内联函数，就能像调用一个函数那样方便地重复使用一段代码，而不需要付出执行函数调用的额外开销。很显然，使用内联函数会使最终可执行程序的体积增加。
以空间换取时间，或增加空间消耗来节省时间，这是计算机学科中常用的方法。
友元是一种在类体内进行声明，在类外部(即在.cpp实现文件中没有类限定符classA::修饰)实现的全局函数。从语法上看，它与普通函数一样，即在定义上和调用上与普通函数一样。
友元函数关键字friend。友元函数是全局函数，不属于类，在.cpp实现文件中没有类限定符classA::修饰。友元函数的特点是能够访问类中的私有成员。
友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类。
https://blog.csdn.net/erzr_zhang/article/details/51869649

hpp,其实质就是将.cpp的实现代码混入.h头文件当中，定义与实现都包含在同一文件，则该类的调用者只需要include该hpp文件即可，无需再将cpp加入到project中进行编译。
而实现代码将直接编译到调用者的obj文件中，不再生成单独的obj,
采用hpp将大幅度减少调用 project中的cpp文件数与编译次数，也不用再发布烦人的lib与dll,因此非常适合用来编写公用的开源库。
1、是Header Plus Plus 的简写。
2、与*.h类似，hpp是C++程序头文件 。
3、是VCL 专用的头文件,已预编译。
4、是一般模板类的头文件。
5、一般来说，*.h里面只有声明，没有实现，而*.hpp里声明实现都有，后者可以减 少.cpp的数量。
6、*.h里面可以有using namespace std，而*.hpp里则无。
*.hpp要注意的问题有：
a)不可包含全局对象和全局函数
 由于hpp本质上是作为.h被调用者include，所以当hpp文件中存在全局对象或者全局函数，而该hpp被多个调用者include时，将在链接时导致符号重定义错误。要避免这种情况，需要去除全局对象，将全局函数封装为类的静态方法。
b)类之间不可循环调用
  在.h和.cpp的场景中，当两个类或者多个类之间有循环调用关系时，只要预先在头文件做被调用类的声明即可，
c)不可使用静态成员
  静态成员的使用限制在于如果类含有静态成员，则在hpp中必需加入静态成员初始化代码，当该hpp被多个文档include时，将产生符号重定义错误。唯 一的例外是const static整型成员，因为在vs2003中，该类型允许在定义时初始化，如：
linux平台.cpp文件的后缀为.cc
声明和实现写在一个文件中，或者只有实现没有声明的c++工具类，最好写成.hpp文件


搜索：C++11新特性： 1、auto与decltype；2、nullptr与nullptr_t()；智能指针 3、for循环；4、lambda表达式；5、override、final；6、右值引用；7、move构造函数；8、容器初始化。
C++11中的override关键字，可以显式的在派生类(父类？)中声明，哪些虚函数需要被重写，如果没被重写，则编译器会报错。
https://blog.csdn.net/qq_56673429/article/details/124837626
智能指针容器的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。
智能指针的使用方式与普通指针类似。
使用智能指针能轻易写出异常安全的代码，因为当对象退出作用域时，智能指针将自动调用对象的析构函数，避免内存泄露。
C++11中提供了以下三种智能指针，使用这些智能指针时需要引用头文件<memory>:
std::shared_ptr：共享的智能指针，是指多个智能指针可以同时管理同一块有效的内存，是一个模板类，其初始化有三种方式：通过构造函数、std::make_shared辅助函数以及reset方法。
std::unique_ptr：独占的智能指针，1.通过构造函数初始化unique_ptr<int> ptr1(new int(3)); 2.通过移动函数初始化unique_ptr<int> ptr2 = move(ptr1);3.通过reset初始化ptr2.reset(new int(7));
std::weak_ptr：弱引用的智能指针。它不共享指针，不能操作资源，是用来监视shared_ptr中管理的资源是否存在。
利用weak_ptr可以解决shared_ptr的一些问题：1.返回管理this的shared_ptr 2.解决循环引用问题
std::shared_ptr和std::mutex都是C++11的标准类。
//一般的初始化方式
shared_ptr<string> p(new string("normal usage!"));
//推荐的安全的初始化方式
shared_ptr<string> p1 = make_shared<string>("safe uage!");
最安全的分配和使用动态内存的方法是调用一个名为make_shared的标准库函数，此函数在动态内存中分配一个对象并初始化它，返回此对象的shared_ptr。
make_shared函数也定义在头文件memory中。
auto pau = make_shared<string>("auto");    //!更简单，更常用的方式。
#include <memory> // shared_ptr
#include <mutex>  // mutex
#include <pthread.h>
using namespace std;
nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，以往我们使用NULL表示空指针。它实际上是个为0的int值
c++的Lambda的语法如下：[函数对象参数]（操作符重载函数参数）->返回值类型{函数体}
搜索：C++11新增关键字详解:
https://blog.csdn.net/u010168781/article/details/100526303
auto与decltype
nullptr_t 与 nullptr
override表示重写基类的虚函数
final表示禁止重写基类虚函数、或者禁止继承基类
constexpr 与 const 的区别
noexcept
static_assert
alignas 与 alignof
thread_local

c++11之后支持了多线程编程#include <thread>，应用C++11中的std::thread线程类便于多线程程序的移值
c++11线程的创建及启动：
std::thread threadObj01(<callback>); 创建新线程，callback回调函数参数可以是：1.函数指针 2.函数对象 3.lambda表达式
threadObj01.join(); 阻塞主线程等待子线程执行完。当子线程执行完毕后和主线程汇合，然后继续执行主线程。
threadObj01.detach(); 将子线程和主线程分离，分离后子线程失去和主线程的关联，主线程结束后如果子线程还没有结束，那么会在后台继续运行，当子线程执行完毕后，由运行时库负责清理该线程相关资源。
一旦调用了detach(),就不能再调用join(),否则系统会报告异常。
threadObj01.joinable();	用来判断是否可以使用join()或这detach()。True：可以进行join()或detach(), False：不能进行join()或detach()
重写class的()操作符：void ThreadA::operator()(int param){...}

c++多线程同步(容器)：
mutex是锁，std::unique_lock是锁容器，std::condition_variable是锁容器标记.条件变量。std::unique_lock为锁管理模板类，是对通用mutex的封装。
std::unique_lock也可以提供自动加锁、解锁功能，比std::lock_guard更加灵活，但使用std::unique_lock需要付出更多的时间、性能成本
https://zh.cppreference.com/w/cpp/thread/unique_lock
#include <thread>
#include <mutex>
#include <condition_variable> 
#include <atomic>
#include <memory> // shared_ptr
#include <chrono>
std::mutex mutexObj01; //全局互斥锁
std::condition_variable lckNotify;   //条件变量: 阻塞(当前线程).唤醒其他线程
const std::lock_guard<std::mutex> lck(mutexObj01); //上锁
const std::unique_lock<std::mutex> lck(mutexObj01); //上锁
lckNotify.wait(std::unique_lock); //当前线程被阻塞，在当前线程被阻塞时，该函数会自动调用 ​​lck.unlock() 释放锁，使得其他被阻塞在锁竞争上的线程得以继续执行。​
lckNotify.notify_all(); //唤醒所有线程.
lckNotify.notify_one(); 
互斥锁mutex本质就是一个特殊的全局变量，拥有lock和unlock两种状态，unlock的互斥锁可以由某个线程获得，一旦获得，这个互斥锁会锁上变成lock状态，此后只有该线程由权力打开该锁，其他线程想要获得互斥锁，必须得到互斥锁再次被打开之后
C++中，通过构造std::mutex的实例来创建互斥元，可通过调用其成员函数lock()和unlock()来实现加锁和解锁，这是不推荐的做法，因为这要求程序员在离开函数的每条代码路径上都调用unlock()，包括由于异常所导致的在内。
作为替代，标准库提供了std::lock_guard类模板，实现了互斥元的RAII惯用语法（资源获取即初始化）。该对象在构造时锁定所给的互斥元，析构时解锁该互斥元，从而保证被锁定的互斥元始终被正确解锁。
https://www.cnblogs.com/jzincnblogs/p/5188051.html
在WIN32中，同步机制主要有以下几种：（1）事件(Event);（2）信号量(semaphore);（3）互斥量(mutex);（4）临界区(Critical section)。
linux c++线程同步的常见方法：互斥锁，条件变量，读写锁，信号量
std:call_once是C++11引入的新特性
https://zhuanlan.zhihu.com/p/513402061
unique_lock 和 lock_guard的区别：
unique_lock是个类模板，工作中，一般lock_guard(推荐使用)；lock_guard取代了mutex的lock()和unlock();
unique_lock比lock_guard灵活很多，效率上差一点，内存占用多一点。
为什么说unique_lock更灵活？
  unique_lock可以通过unlock()和lock()主动进行解锁和获取锁的操作，而不一定需要等到相应的变量被释放才释放锁
  lock_guard 只能够通过相应变量的生命周期来控制锁的获取和释放  
什么时候需要用到unique_lock?
  在进行多线程编程的时候，我们常常会碰到拿到锁的释放与再获取的情况，比如：
  我们将某个task分成了 1/2/3 三个部分，1和3由线程A完成， 中间2由线程B完成。
  那么，正常的处理flow就是， 线程A处理 task 1， 然后等待， 转线程B处理 task 2， 处理完成后，通知线程A，线程A继续处理 task 3。
  在处理整个事情的过程中，都要获取同一个锁 M， 那么在A处理了 task 1，就应该释放掉锁，然后线程B才能获取到锁M， 否则， 就出现了死锁。
  所以，这里有一个需求， 那就是这个锁可以主动释放和再获取， 也就是要用的 unique_lock
  另外还有一个需求，那就是线程B完成task的中部分之后，需要通知线程A， 这个通知怎么完成， 这个可以通过std::condition_variable 来完成。



进程组.进程.线程池
异步IO的事件框架
http://www.zhihu.com/question/23156257
函数入口.生命周期.事件机制：调用流程

不同OS调度.管理线程的方式是不一样的
c++多线程同步：
使用新的mutex互斥锁机制，而不是过去普遍出现在内核中的semaphore信号量机制
软中断信号

c++没有反射怎么实现json对象的序列化和反序列化？
-------------------------------------------------------------------------------------------------------------
c++编译.链接：

java的编译器只有sun一家的， 而c++的编译器有多个版本
所以java的实现标准统一，而c++有多个不同的实现？

c++标准只有声明，没有实现？由各个编译器实现？
http://www.cplusplus.com/reference/cstring/
http://libcxx.llvm.org/

c标准委员会和C++标准委员会
各大编译器厂商都会以它的标准为设计编译器。只有符合ANSI标准的基础下，各自厂商才可以对各语言进行扩展。

Standard C++基金会
https://isocpp.org/


编译环境问题：
编译器分类.版本.编译选项
标准库版本/第三库版本
http://www.zhihu.com/question/20201972

GCC使用的C++标准库是libstdc++
这是项目地址：http://gcc.gnu.org/libstdc++/

clang++用的C++库：
http://libcxx.llvm.org/
svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx

/usr/include/c++/4.6/bits/stl_queue.h

windows下c++ 标准库路径
linux下c++ 标准库路径
http://www.cnblogs.com/qq78292959/archive/2012/03/21/2409378.html

Source Insight常用快捷键：
Ctrl + F 字符串全文搜索
选择一个变量或方法后右键Lookup References…就可以进行查找
Alt +, 后退；Alt+.前进.
Alt + G (或者F7) 打开Symbol Window.

source insight 3.5的注册码：
SI3US-361500-17409

make
http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html

http://blog.csdn.net/zengraoli/article/details/11522563
http://blog.csdn.net/windows_nt/article/details/9630567
http://blog.sina.com.cn/s/blog_5cf4a61d0100xr00.html
http://bbs.9ria.com/thread-206437-1-1.html
http://www.himigame.com/curl-libcurl/878.html
http://blog.csdn.net/w13770269691/article/details/8847800


平台类型：linux、windows
平台位数：32、64
平台动态链接库的依赖问题
指定编译器版本 	编译选项	Makefile方式编译?
编译器类型：编译可以用gcc/g++,而链接可以用gcc -lstdc++或者g++
编译器位数
编译.链接.运行时默认的文件查找路径及顺序，以及文件名
默认头文件.类库.命令的查找路径及顺序
平台开发时的api接口
http://www.cnblogs.com/zyl910/archive/2012/08/14/gcc64_make.html
http://tieba.baidu.com/p/234600296
http://blog.csdn.net/duguteng/article/details/22036561

eclipse中添加第三方库
http://blog.sina.com.cn/s/blog_6f74890d01018zsm.html
http://blog.163.com/baosongliang@126/blog/static/194935702013101335758601/
http://howtofix.pro/how-to-solveduring-startup-program-exited-with-code-0xc/

gcc和g++的区别和联系是什么:
（1）gcc和g++都是GNU(组织)的一个编译器。
（2）后缀名为.c的程序和.cpp的程序g++都会当成是c++的源程序来处理。而gcc不然，gcc会把.c的程序处理成c程序。
（3）对于.cpp的程序，编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。（个人觉得这条是最重要的）	

编译器的工作过程
http://kb.cnblogs.com/page/508336/
开发者可以在编译阶段选择可执行文件连接外部函数库的方式：到底是编译时连接.静态连接  还是运行时连接.动态连接
现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。
动态连接是外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；
缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。

Linux下c++编程：
1，使用gedit，或者任何文本编辑器（最好有语法高亮，自动缩进功能）编写您的代码。
2，编写代码时，使用标准库的函数和数据结构，或者其它已经实现的模块，或者linux系统API调用。
3，碰到不知道的标准库，或者linux API，使用man命令查询，没有的话，到网上查询。
4，编写makefile.	(自动生成Makefile文件：autoscan, aclocal, autoconf, automake这四个工具.)
5，在g++上添加 -g参数，加入调试符号。
6，使用gdb调试或者打印log测试。
7，去掉-g参数，release。
8，结束。
工具介绍：
gcc/g++ 编译器 
gdb 调试工具 
valgrind 内存泄露检查 
doxygen 文档组织工具
c++常用第三方库： GTK, QT,STL，boost、curl、socket库、解析xml/json库

-------------------------------------------------------------------------------------------------------------
新语言学习：
单例实现
观察者模式
回调
字符串查找.替换.拼接.截取.分割.判断包含/相等.下标.长度、切片操作模版如下：string[start: end: step]
容器.算法.迭代器：容器的创建.c.r.u.d操作.截取.下标.长度.判断包含、切片操作
文件内容的C.R.U.D操作
图片的C.R.U.D操作
网络访问.JSON序列化，反序列化
多线程下载+断点续传
线程的创建，多线程同步
线程池
c++ LogUtil打印类名，函数名，行号：
#define DEBUG (printf("%s.%s(%d): aaaaaaa--######= ",__FILE__, __FUNCTION__, __LINE__), printf)
int main(int argc, char** argv)
{
        DEBUG("hello world\n");
		system("pause");
        return 0;
}
https://blog.csdn.net/dldw8816/article/details/59516929
https://blog.csdn.net/cabinriver/article/details/8960119
c++ LogUtil打印线程堆栈：
https://zhuanlan.zhihu.com/p/426518821
/*
 * dump 堆栈信息
 * */
void DumpTraceback(int signal) {
    const int size = 200;
    void *buffer[size];
    char **strings;
​
    int nptrs = backtrace(buffer, size);
    printf("backtrace() returned %d address\n", nptrs);
​
    // backtrace_symbols函数不可重入， 可以使用backtrace_symbols_fd替换
    strings = backtrace_symbols(buffer, nptrs);
    if (strings) {
        for (int i = 0; i < nptrs; ++i) {
            printf("%s\n", strings[i]);
        }
        free(strings);
    }
}
异常处理
c++常用第三方库： GTK, QT,STL，boost、curl、socket库、解析xml/json库

c.biancheng.com
https://www.cnblogs.com/qq21497936/p/12990814.html

搜索：C++常用头文件及函数、
搜索：c++如何查看系统头文件中的常用函数，参数及文档
搜索：C++中string类函数常用函数大全


-------------------------------------------------------------------------------------------------------------
CMakeList.txt编译脚本：

https://zhuanlan.zhihu.com/p/82417676
CMake文件中命令是不区分大小写的，但是变量是区分大小写的

cmake：
cmake_minimum_required(VERSION 3.4.1)
project(projectName)
使用set(params)命令, 就可以定义一个变量。cmake取变量值：${varName}进行变量的引用。在 IF 等语句中,是直接使用变量名而不通过${}取值			
set(CMAKE_GENERATOR "MinGW Makefiles")
set(CMAKE_C_COMPILER "D:\\software_install\\TDM-GCC-64\\bin\\x86_64-w64-mingw32-gcc.exe")
set(CMAKE_CXX_COMPILER "D:\\software_install\\TDM-GCC-64\\bin\\x86_64-w64-mingw32-g++.exe")
set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS}") #设置C编译选项
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11") #设置C++编译选项
set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -s")
set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -s")

message(STATUS "C_COMPILER: ${CMAKE_C_COMPILER}")
message(STATUS "CXX_COMPILER: ${CMAKE_CXX_COMPILER}")
message(STATUS "C_FLAGS: ${CMAKE_C_FLAGS}")
message(STATUS "CXX_FLAGS: ${CMAKE_CXX_FLAGS}")

add_subdirectory(params)  #include sub CMakeLists.txt 
aux_source_directory(./src SRC_LIST) #可有多个
aux_source_directory(./src SRC_LIST02) 
include_directories(./include ./include02)  	#可有多个
include_directories(./include04 ./include05)
add_executable(projectName ${SRC_LIST} ${SRC_LIST02})

#dependence:
add_library(params)分为源文件导入和库文件导入，库文件导入还需要调用set_target_properties(params)命令指定库文件的具体位置。
find_library(params)
在target_link_libraries(params)链接命令中，find_library(params)中的库变量需要用${libName}取变量值，而add_library(params)中的库变量不需要用${}取值，直接用libName。
即：
add_library(yuv SHARED xx.cpp)
add_library(templete SHARED IMPORTED)
set_target_properties(templete PROPERTIES IMPORTED_LOCATION    ${CMAKE_CURRENT_SOURCE_DIR}/src/main/jniLibs/${ANDROID_ABI}/libOMAFPlayer.so)
find_library(log-lib log)
target_link_libraries(yuvutil ${log-lib} yuv templete)

https://wangpengcheng.github.io/2019/08/13/learn_cmake/
cmake内置变量.内置函数：
CMAKE_C_COMPILER：指定C编译器
CMAKE_CXX_COMPILER：指定C++编译器
EXECUTABLE_OUTPUT_PATH：指定可执行文件的存放路径
LIBRARY_OUTPUT_PATH：指定库文件的放置路径
CMAKE_CURRENT_SOURCE_DIR：当前处理的CMakeLists.txt所在的路径
CMAKE_BUILD_TYPE：控制构建的时候是Debug还是Release命令：set(CMAKE_BUILD_TYPE Debug)
CMAKE_SOURCR_DIR：无论外部构建还是内部构建，都指的是工程的顶层目录（参考project命令执行之后，生成的_SOURCR_DIR以及CMake预定义的变量PROJECT_SOURCE_DIR）
CMAKE_BINARY_DIR：内部构建指的是工程顶层目录，外部构建指的是工程发生编译的目录（参考project命令执行之后，生成的_BINARY_DIR以及CMake预定义的变量PROJECT_BINARY_DIR）
CMAKE_CURRENT_LIST_LINE：输出这个内置变量所在的行。
${CMAKE_CURRENT_SOURCE_DIR}表示CMakeLists.txt文件的绝对路径
${CMAKE_CURRENT_BINARY_DIR}
${CMAKE_CURRENT_LIST_DIR}表示CMakeLists.txt文件的绝对路径
${CMAKE_CURRENT_LIST_FILE}
${CMAKE_INCLUDE_CURRENT_DIR}
${PROJECT_SOURCE_DIR}
使用$ENV{NAME}指令就可以调用系统的环境变量了,比如MESSAGE(STATUS “HOME dir: $ENV{HOME}”)。设置环境变量的方式是: SET(ENV{varName} value)
三,FIND_指令
FIND_系列指令主要包含一下指令:
FIND_FILE(<VAR> name1 path1 path2 ...)VAR 变量代表找到的文件全路径,包含文件名
FIND_LIBRARY(<VAR> name1 path1 path2 ...)VAR 变量表示找到的库全路径,包含库文件名
FIND_PATH(<VAR> name1 path1 path2 ...)VAR 变量代表包含这个文件的路径。
FIND_PROGRAM(<VAR> name1 path1 path2 ...)VAR 变量代表包含这个程序的全路径。
FIND_PACKAGE(<name> [major.minor] [QUIET] [NO_MODULE][[REQUIRED|COMPONENTS] [componets...]])
https://www.cnblogs.com/xianghang123/p/3556425.html
cmake处理多源文件目录的方法
https://blog.csdn.net/gubenpeiyuan/article/details/8667035
git@github.com:xufuji456/FFmpegAndroid.git
https://github.com/yishuinanfeng/YuvVideoPlayerDemo.git

https://www.cnblogs.com/coderfenghc/archive/2012/06/18/2553964.html
https://www.cnblogs.com/coderfenghc/archive/2012/06/19/2555388.html

https://blog.csdn.net/afei__/article/details/81201039
https://www.cnblogs.com/coffee520/p/10118852.html
https://www.cnblogs.com/rswss/p/9460139.html
https://blog.csdn.net/u012150179/article/details/17852273
MinGW(GCC的Windows移植版)
MinGW64：https://sourceforge.net/projects/mingw-w64/
tdm64-gcc-5.1.0-2W(GCC的Windows-64移植版)

c++调用第三方库，最好用源码来自己编译，避免c++因编译.链接带来的乱七八糟的问题。
编译.链接时：
默认头文件查找路径及头文件名
默认类库查找路径及库文件名
运行时：
默认类库查找路径及库文件名
编译：查看语法错误，因语法错误编译失败，出现类似“某某未定义”的错误。
链接：查找外部符号的定义，在链接时会出现“未处理的外部符号‘某某’，该符号在某某位置处被引用”的错误。

编译时系统默认.h文件的搜索路径及顺序：
1. gcc编译时，可以设置-I选项以指定头文件的搜索路径，如果指定多个路径，则按照顺序依次查找。
Makefile中指定.h文件的搜索路径，gcc/g++命令行中指定.h文件的搜索路径
".h" 先在当前目录下搜索，再在系统目录下搜索   
<.h> 只在系统目录下搜索
.h搜索只具体到文件/具体到目录，但不会递归去查找文件
2.通过查找gcc的环境变量C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH来搜索头文件位置。
3. 再找内定目录搜索，分别是
 /usr/include
 /usr/local/include
 /usr/lib/gcc-lib/i386-linux/2.95.2/include  (gcc-lib头文件目录)

链接：
默认命令.类库.头文件的查找路径及顺序
LIBRARY_PATH 连接时库文件的搜索路径
LD_LIBRARY_PATH运行时库文件的搜索路径
http://blog.chinaunix.net/uid-20620288-id-3157119.html
http://blog.csdn.net/statdm/article/details/7751000


查看so文件的相关内容，先安装tdm-gcc-64.exe软件：
1. nm -D libxxx.so | grep 'functionName'  #打印so中的符号信息
2. rmp -qfl libxxx.so #查看里边包含的内容、头文件等
3. readelf -as libxxx.so	#读取elf信息
4. objdump -d -v libxxx.so		#查看这些工具是如何完成这项任务
   objcopy
5. ldd libxxx.so	#查看依赖关系。readelf libxxx.so | grep 'NEEDED'这样也可以查看依赖关系
6. file libxxx.so	#查看so的属性
7. strings libxxx.so 	#查看so中的字符串
8. ar命令可以用来创建、修改库，也可以从库中提出单个模块
https://wenku.baidu.com/view/179296f253e2524de518964bcf84b9d528ea2ce5.html
https://blog.csdn.net/weixin_42364852/article/details/116652119
Linux中以下命令可以查看可执行文件的依赖库：ldd a.out Makefile xxd
注意：在修改了 /etc/ld.so.conf 文件或者在系统中安装了新的函数库之后，需要运行一个命令：ldconfig ，该命令用来刷新系统的共享库缓存，即 /etc/ld.so.cache 文件
nm命令可以列出一个函数库文件中的符号表
nm、ar、ldd、ldconfig和ld.so 
win平台关于加载dll文件的顺序，如下:
应用程序所在目录→当前目录→Windows SYSTEM目录→Windows目录→PATH环境变量指定的路径
Dependency Walker 、Process Explorer
-------------------------------------------------------------------------------------------------------------
c++ IDE: 
vs code(开源, 跨平台, 轻量级)+tdm64-gcc-5.1.0-2W(GCC的Windows-64移植版)+cmake/cmake-gui.exe(cmake --help，CMakeList.txt)+ninja(ninja --help)
MinGW(GCC的Windows移植版)
eclipse+CDT
Dev c++
Emacs
http://c.biancheng.net/view/1740.html  


1.C++环境搭建：c++代码编写，代码自动补全*

2.CMakeList.txt脚本编写

cmake命令行编译：
(工程根目录下一定要有一个CMakeList.txt编译脚本，即build目录的上一级目录下一定要有一个CMakeList.txt编译脚本)：
cmake --help
mkdir build && cd build
cmake -G "Ninja" ..
ninja -j 64
ninja install
或者
cmake -G "MinGW Makefiles" ../   #只能在cmd窗口运行，不能用git-bash运行
mingw32-make.exe
搜索：cmake环境变量设置
搜索：cmake脚本编写 https://zhuanlan.zhihu.com/p/493250684
g++的c++11命令行编译：
-std=c++11、源文件.头文件.库文件.输出文件(目标文件)、警告.优化.功能feature 、-D定义宏
-fpic生成与位置无关的代码
-shared生成动态库、-static生成静态库、默认生成可执行文件
g++ -std=c++11 src01/*.cpp src02/*.[ch]pp src03/* -I include01/ -I include02/*.h -L. -lpthread -llib02 -o a.out -Wall -O2 -frtti -fexceptions -D__SOLA_LOGGING_ENABLED 


vscode插件：c/c++、C++ Intellisense(代码补全)、Code Runner(运行代码)、Cmake、Cmake Tools、Remote-SSH(两端都要打开vscode)、Bracket Pair Colorizer(括号匹配)、highlight-words(选中字符高亮)/highlight-icemode
vs code远程开发：teamviewer
代码编写：代码自动补全
代码阅读：
a.打断点+改背景色、打log、弹toast、断点调试可查看父类引用指向子类对象时的具体的实现子类，或大log打印父类引用的类名
1.全局文件搜索查找(vim)Ctrl-p  
2.全局字符串查找	
3.查看定义-右键go define
4.查看所有的引用-右键find all references
5.头文件和源文件相互跳转-右键
http://t.zoukankan.com/echolun-p-10872717.html
代码阅读基本快捷键4个一定要有： 
1.根据文件名查找文件 
2.全局字符串搜索 
3.4.查看变量.方法的定义及所有引用

右键点击Ctrl-Shift-p，输入cmake，选中Cmake:Configure 开始配置，选中Cmake:build 开始编译
Ctrl-Shift-o 	查看方法.属性列表
右键点击Alt-o 	.h和.cpp文件相互切换


VS-Image Watch插件
https://blog.csdn.net/iracer/article/details/83413877
https://docs.opencv.org/2.4/doc/tutorials/introduction/windows_visual_studio_image_watch/windows_visual_studio_image_watch.html#windows-visual-studio-image-watch
https://opencv.org/image-watch-plugin-for-visual-studio/
https://blog.csdn.net/qq_15947787/article/details/72804292
video： https://channel9.msdn.com/posts/Introducing-Image-Watch
Image Watch窗口左上角的单选按钮（Locals / Watch）选择下面的图像列表中显示的内容：
Locals列出当前作用域中的所有OpenCV图像对象（此列表自动填充）。 
Watch显示已固定用于连续检查的图像表达式。 
左侧图像列表显示基本信息，例如宽度，高度，通道数，以及缩略图（如果有），右侧大图显示当前鼠标位置像素的坐标和色彩分量值。
在右侧图像上使用滚轮操作实现缩放，放大到一定尺寸后将同时显示像素的BGR分量，如上图所示。
Ubuntu 18.04中安装gdb-imagewatch的方法
https://blog.csdn.net/m0_46244540/article/details/104452472

-------------------------------------------------------------------------------------------------------------
基于opencv的人脸检测系统
基于opencv的人脸识别系统
基于opencv的车牌识别系统




