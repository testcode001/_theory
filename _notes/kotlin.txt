面向过程.面向对象+OC+shell+c++
继承类似于c++用: ，形参类似于OC和python(方法定义的形参可以有默认值，调用时可不传值)，定义变量函数类似于js用var.val(变量名在前，数据类型在后，用:分割)，变量取值类似于shell用${}


kotlin：定义，及调用
访问权限修饰符(public.internal.protected.private)、override继承重写修饰符(open.abstract、final)：分别修饰类，方法，属性
变量：静态变量即companion object代码块、常量const val 变量名:数据类型、普通变量var 变量名:数据类型、集合(可变的和不可变的) 变量取值用${varName}类似于shell
方法(fun +名字.形参 : 返回值)：普通方法fun 、静态方法即companion object代码块、默认final方法、构造方法(主构造函数、次级构造函数constructor)+init{...}代码块，方法的重写override
inline内联函数与lamada表达式：在使用函数作为另一个函数的参数（所谓的高阶函数）比在Java中更自然
普通类class.接口interface：，接口实现
data class数据类即model类
abstract class抽象类，open class开放类
enum class枚举类
inner class内部类
sealed class密封类.类似于枚举
object用来定义单例类(用object替换class即可)或者定义匿名内部类的变量名.设置匿名内部类方法
private var mThread = object : Thread() {
     override fun run() { 
         println("running from Thread:${Thread.currentThread()}")
     }
}

kotlin基本教程：
https://www.runoob.com/kotlin/kotlin-loop-control.html
https://www.runoob.com/linux/linux-shell-func.html
Kotlin在匿名内部类中，引用外部类的this当前对象：写法是this@OuterClass，OuterClass.this是java的写法。
Kotlin和java可以相互调用，但同一个文件内只能使用java或kotlin语法
kt：
类定义倒数第一个:之后的是继承的父类
方法定义花括号{}后的第一个:之前的是返回值类型
OtherService::class.java
函数返回值是函数里面最后一行，或者用return指定
如果函数只有一句话的话，可以简化为赋值的方式，并且可以简化掉函数定义的返回值。例如：
fun getOtherService() = HttpConfig.service(OtherService::class.java)
kotlin用形参默认值来实现函数重载

kotlin接口创建实例对象： object : BottomDialogUtil.OnClickListener(){
  override fun onClick(dialog: DialogInterface): Boolean{
                     return false;
                }
	}
kotlin object类和compian object方法的区别？
object 关键字可以表达两种含义：一种是对象表达式，用来创建interface的匿名实例对象,
另一种是类声明， 用object 修饰的类为静态单利类，里面的方法和变量都为静态的。？
object 修饰的类是单例类，里面的方法和变量看怎么定义了（普通还是普通），静态方法可应用@JvmStatic表示。？
companion object 修饰为伴生对象,伴生对象在类中只能存在一个，类似于java中的静态方法 Java 中使用类访问静态成员，静态方法。


Kotlin之数组和集合：基础数据类型数组、复杂数据类型数组
https://www.jianshu.com/p/6d95db6e9f87
https://www.jianshu.com/p/e75795be48c8
https://www.cnblogs.com/Jetictors/p/9237108.html
https://www.cnblogs.com/Jetictors/p/9241867.html
https://github.com/Jetictors
private var mTexId = arrayOfNulls<Int>(1)
private var mTextureMatrix = FloatArray(16)
private var mVertexCoordArray: FloatArray = floatArrayOf(-1f,1f)
private var mVideoBeanList:MutableList<VideoDataBean> = mutableListOf<VideoDataBean>()
setOf();该函数返回不可变的Set集合，该集合可以接收0个或过个参数，这些参数将作为集合的元素。
mutableSet0f()：该函数返回可变的MutableSet集合，
hashSetOf()：该函数返回可变的HashSet集合，
linkedSetOf():该函数返回可变的LinkedHashSet集合。
sortedSetOf()：该函数返回可变的TreeSet集合, 用法同下。

mapOf(); 该函数返回不可变的Map集合。
mutableMapOf(); 该函数返回可变的MutableMap集合。
其实mapOf() 返回的是LinkedHashMap()。
hashMapOf(); 返回可变的HashMap()集合。
linkedMapOf(); 返回可变的LinkedHashMap集合。
对于map的添加删除和java一样 put， remove。我就不举例子了。
遍历map、数组、集合等
for(en in map.entries) {}
for(key in map.keys) {}
for(value in map.values) {}
map还可以用map[key] = value,来代替map.put("key", value)

开启新线程、多线程同步

Kotlin中没有new关键字: 我们可以像使用普通函数那样使用构造函数创建类实例：val site = Strdent()
companion object{...}伴生对象相当于静态代码块用来定义静态变量或者静态方法，在类中只能存在一个

kotlin用as?实现强制类型转换，类似于python。如下：
val person: Person = Person()
val student:Student? =person as? Student
println(student) // null

kotlin的is就是java的instanceof。如下：
if(zhansan is Student){...} 

在Kotlin中用when来代替switch操作符。else同switch的default。如果是多行语句，记得加花括号{}
https://www.jianshu.com/p/01eaac5f8767
val i = 5
when (i) {
    5 -> print("5")
    4 -> print("4")
    3 -> print("3")
    2 -> print("2")
    1 -> print("1")
	else -> toast("gone")
	
}
val res = when {
    x in 1..10 -> "cheap"
    s.contains("hello") -> "it's a welcome!"
    v is ViewGroup -> "child count: ${v.getChildCount()}"
    else -> ""
}

kotlin中的return、break、continue、标签
Kotlin中的任意表达式都可以标记为一个label。Label 由一个标记符跟上 @ 符号构成。
例如 abc@，fooBar@，为了标记一个表达式，我们只需要在它前面加一个 label 即可。
loop@ for (i in 1..100) {
  // ...
}
我们可以使用 label 来限制一个 break 或者一个 continue 语句：
loop@ for (i in 1..100) {
  for (j in 1..100) {
    if (...) break @loop
  }
}

inline内联函数与lamaba表达式
inline fun consume(f: () -> Unit): Boolean {
    f()
    return true
}
override fun onOptionsItemSelected(item: MenuItem) = when (item.itemId) {
    R.id.home -> consume { navigateToHome() }
    R.id.search -> consume { MenuItemCompat.expandActionView(item) }
    R.id.settings -> consume { navigateToSettings() }
    else -> super.onOptionsItemSelected(item)
}

Kotlin之let,apply,with,run函数区别
let()的定义是这样的，默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return
fun testLet(): Int {
    // fun <T, R> T.let(f: (T) -> R): R { f(this)}
    "testLet".let {
        println(it)
        println(it)
        println(it)
        return 1
    }
}
//运行结果
//testLet
//testLet
//testLet
apply函数是这样的，调用某对象的apply函数，在函数范围内，可以任意调用该对象的任意方法，并返回该对象。
apply用起来和java里的构造者模式很像，比如我们自定义个View，采用构造者模式来初始化View的各个属性，用apply很简单就可以实现：
fun createMyTextView(context: Context) = MyTextView(context).apply {
    text = "my text view"
    textSize = 20.0
    setPadding(10,10,10,10)
}
run函数和apply函数很像，只不过run函数是使用最后一行的返回，apply返回当前自己的对象。
with和apply是kotlin标准库中的函数，用来对一个对象进行多次操作。
with函数是一个单独的函数，并不是Kotlin中的extension，所以调用方式有点不一样，返回是最后一行，然后可以直接调用对象的方法，感觉像是let和apply的结合。
with把StringBuild委托给后边lambda，lambda里可以直接用this指代StringBuild或者直接调用StringBuild的方法：
fun alphabetWith() = with(StringBuilder()) {
        append("alphabet:\n")
        for (letter in 'A'..'Z') {
            this.append(letter)
        }
        append("\nI know the alphabet")
        this.toString()
    }
with的返回值是lambda的值，即最后lambda的一行，而apply返回的是整个对象
https://www.jianshu.com/p/605a382bff0c
https://www.jianshu.com/p/e7abbfb109ac
https://www.jianshu.com/p/5c4a954d2b2c
android权限相关：
https://blog.csdn.net/wangpf2011/article/details/80589648
https://blog.csdn.net/qq_36523667/article/details/78917460
--------------------------------------------------------------------------------------------

kotlin视频教程 
https://www.jianshu.com/p/c69d63b70650
闭包(closure)
http://www.365yg.com/item/6446657322759488014/
https://www.runoob.com/kotlin/kotlin-extend.html
var变量
const val常量
https://www.jianshu.com/p/e8752c880088
https://www.kotlincn.net/docs/reference/object-declarations.html
变量取值类似于shell用${varName}
https://blog.csdn.net/qq_30219217/article/details/73381503
定义变量时，可在类型后面加一个问号?，表示该变量是Nullable，不加或者加个!表示该变量不可为null。如下：
var s:String? = null
var s2:String = "xxx" //如果该变量被赋值为null，则编译不通过
对于可以为null的变量，在调用该变量方法的时候，必须用变量名+?(如上面的s?)的形式进行调用，表示如果该变量为null，则不执行该变量调用的方法。如：
var l= s?.length//如果s为null，则不执行length方法，从而避免了java中频繁的空指针异常。
对于不可以为null的变量，在调用该变量方法的时候，必须用变量名+!!的形式进行调用。如var l= s!!.length
所有成员变量(包括定义在类中，以及直接定义在kt文件中的)在定义时必须进行初始化，局部变量（定义在方法内）可以不进行初始化。

lateinit与by lazy{...}代码块：
lateinit只用于变量var且只能用于复杂数据类型，而by lazy{...}代码块只用于常量val。
by lazy{...}代码块只在第一次调用的时候执行代码，并记录结果，再次调用只返回记录的结果
变量名在前，数据类型在后
private lateinit var name: String 		//lateinit是用来告诉编译器，name这个变量后续会妥善处置的。lateinit只能用于对象，且该对象不可为Nullable，不能用于基础数据类型
private var name: String = "zhangsan"  
类属性或者局部变量定义必须用var或者val修饰，局部变量可不写变量类型:DataTpye，因为有自动类型推到？如果局部变量没有初始化 则需要明确表明 变量类型
类的主构造函数最好有val或var修饰，这样形参可在整个类中访问(即属于类的属性成员)。但类的次构造函数形参一定不能有val或var修饰。形参可选用var或者val修饰,但必须有变量名:变量类型？。
注意：主构函数不能包含任何代码，初始化代码放在以init关键字作为前缀的初始化块中；可以没有init，也可以有多个init，init的执行顺序是根据写的顺序来的
//初始化语句块
 init {
     mName=_name
}
定义方法必须以fun开头，函数的返回值用:分隔。Unit表示无返回值，可省略
函数的变长参数可以用 vararg 关键字进行标识：fun update(vararg v:Int){...}

constructor主构造函数（在类体外部声明.直接放在类名后面，通常为主要而简洁的初始化类的方法）和次构造函数声明必须有前缀constructor（在类体内部声明）
如果类有一个主构造函数，每个次构造函数必须使用this关键字通过直接或间接委托别的次构造函数委托给主构造函数。次构造函数最终都是调用主构造函数来创建对象的。
创建对象的调用顺序：先调用主构造函数->直接代理主函数的构造函数->间接代理主函数的构造函数->我们调用的构造函数。
Koltin中的类可以有一个主构造器，以及一个或多个次构造器，主构造器是类头部的一部分，直接放在类名后面:
class Person(var firstName: String) {...} //private可见度修饰符是可选的
当我们定义一个类时，我们如果没有为其显式提供主构造函数，Kotlin编译器会默认为其生成一个无参主构造，这点和Java是一样的。
测试代码如下：
class Person(var from: String) {
    /*属性from*/
    //已经在主构造函数中声明 private var from: String = ""
    /*次构造方法*/
    constructor(from1: String, name: String) : this(from1) {
        println("constructor, from:$from1\n")
    }
 
    companion object {
        val instance = Person("companion")
 
        /*伴生对象中的初始化代码*/
        init {
            println("companion init 1\n")
        }
 
        init {
            println("companion init 2\n")
        }
 
        /* 伴生对象中不允许有构造函数
        constructor() {
            println("companion constructor\n")
        } */
    }
 
    /*初始化代码块*/
    init {
        println("init 2, from:${from}\n")
    }
 
    /*初始化代码块*/
    init {
        println("init 1, from:${from}\n")
    }
 
}
 
fun main(args: Array<String>) {
    println("调用次构造方法:\n")
    Person("main1", "name1")
 
    println("\n\n调用主构造方法:\n")
    Person("main2")
}
fun main(args: Array<String>) {
    println("\n\n调用主构造方法:\n")
    Person("main2")
 
    println("\n\n调用次构造方法:\n")
    Person("main1", "name1")
}
 
super<父类名.接口名>.method()表明你想调用哪个父类.接口的方法
父类中open或者abstract的class和method，才可以被子类继承和强制显式override。继承方式类似于c++用: 且kotlin继承类和实现接口都共用:
Kotlin的类声明默认是final和public的
使用fun声明的函数默认为final修饰，不能被子类重写。如果允许子类重写该函数，那么就要手动添加 open 修饰它, 子类重写方法使用 override 关键词
Kotlin中的类和接口跟Java中对应的概念有些不同，比如接口可以包含属性声明。嵌套类并不是默认在内部的。它们不包含外部类的隐式引用。
重写属性和重写方法其实大致是相同的，但是属性不能被重载。
companion object {}中用来修饰 静态常量，或者静态方法，单例等等

kotlin面向对象-委托和代理关键字by
data class数据类即model类，其构造函数中必须存在至少一个参数，并且所有参数必须使用val或var修饰。数据类不能继承其他类 (但是可以实现接口)。
data class必须满足以下要求:
1.主构造函数至少有一个参数，且主构造函数的所有参数需标记为val 或 var;
2.数据类不能是抽象abstract、开放open、密封sealed或者内部inner的;
如果data class需要无参构造函数,则所有属性必须有默认值:
data class User(val name: String = "", val age: Int = 0)
数据类不能继承其他类 (但是可以实现接口)
https://www.runoob.com/kotlin/kotlin-data-sealed-classes.html
https://www.cnblogs.com/Jetictors/p/8647968.html
https://www.jianshu.com/p/163ed3618788

class Hello
val clazz = Hello::class.java  // 拿到的是 Kotlin 的 KClass。如果想要拿到 Java 的 Class 实例，那么就需要 类名.class/对象.getClass();/Class.forName("");。
启动页面如下：
var intent: Intent = Intent(this, UserListActivity::class.java)
startActivity(intent)
kotlin语法跟java的不同
https://www.cnblogs.com/dubo-/p/6880599.html
闭包即.匿名函数.花括号代码块，格式如下
([Type param01...]) {
  codeBlock;
};
运算符重载关键字operator

kotlin - Coroutine协程：
协程就像非常轻量级的线程。线程是由系统调度的，线程切换或线程阻塞的开销都比较大。而协程依赖于线程，但是协程挂起时不需要阻塞线程，几乎是无代价的，协程是由开发者控制的。所以协程也像用户态的线程，非常轻量级，一个线程中可以创建任意个协程。
https://www.jianshu.com/p/76d2f47b900d


kotlin开启新线程：
https://www.jianshu.com/p/3963e64e7fe7
private var mThread = object : Thread() {
     override fun run() { 
         println("running from Thread:${Thread.currentThread()}")
     }
}.start()
private var mThread = Thread({
     println("running from lambda:${Thread.currentThread()}")
}).start()
private var mThread = thread(start=true) {
    println("running from thread():${Thread.currentThread()}")
}
我们正在使用thread()方法，它会神奇地隐藏所有的样板代码。事实上，下面将展示完成的thread()方法：
public fun thread(start: Boolean = true, isDaemon: Boolean = false, 
                  contextClassLoader: ClassLoader? = null, name: String? = null, 
                  priority:Int = -1, block: () -> Unit) : Thread {
    val thread = object: Thread() {
        public override fun run() {
            block()
        }
     }
     if (isDaemon) 
        thread.isDaemon = true
     if (priority > 0)
        thread.priority = priority
     if (name != null)
        thread.name = name
     if(contextClassLoader != null)
        thread.contextClassLoader = contextClassLoader
     if(start)
        thread.start()
      return thread
}
多线程同步：
https://www.jianshu.com/p/3963e64e7fe7
在kotlin中使用@Synchronized注解和@Volatile注解，这些注解和Java中的synchronized、volatile有同样的效果。
在kotlin中一个synchronized方法的声明看起来如下所示：
@Synchronized fun synchronizedMethod() {
    println("inside a synchronized method:${Thread.currentThread()}")
}
同步代码块声明如下所示：代码的外观和行为与Java变量非常相似。
fun methodWithSynchronizedBlock() {
    println("outside of a synchronized block:${Thread.currentThread()}")
    synchronized(this) {
         println("inside a synchronized block:${Thread.currentThread()}")
    }
}
kotlin中的Any类和java中的Object相似，但Any并没有wait(), notify() 和 notifyAll() 三个方法。但是你仍然能够使用java.lang.Object的实例作为lock，并且调用相关的方法。
private val lock = java.lang.Object()
fun produce() = synchronized(lock) {
    while(items>=maxItems) { 
        lock.wait()
    }
    Thread.sleep(rand.nextInt(100).toLong())
    items++
    println("Produced, count is$items:${Thread.currentThread()}")
    lock.notifyAll()
}
fun consume() = synchronized(lock) {
    while(items<=0) {
        lock.wait()
    }
    Thread.sleep(rand.nextInt(100).toLong())
    items--
    println("Consumed, count is$items:${Thread.currentThread()}")
    lock.notifyAll()
}

kotlin自定义回调函数interface：
https://www.jianshu.com/p/d31c7cd60ddc

Kotlin调用c/c++代码：
java用关键字native声明jni方法，kotlin用关键字external声明jni方法。如 external fun stringFromJNI():String 声明一个无参返回值为String的jni方法。

https://kotlinlang.org/docs/reference/object-declarations.html

-----------------------------------------------------------------------------------------------
lambda表达式作为形参，调用时传递花括号代码块{}作为参数
函数四要素： 1.名字 2.形参.小括号() 3.返回值 4.函数体.花括号代码块{}
lambda表达式即匿名函数: (参数)->花括号代码块{...}。代码块的最后一行作为函数返回值
lambda表达式的定义、传递(函数可以当参数)、调用
搜索：kotlin lambda 作为形参：
/**
 * (1)传递参数为lambda表达式；
 * (2)泛型的写法；
 */
fun <T1, T2> ifNotNull(value1: T1?, value2: T2?, lambdaParams: (T1, T2) -> (Unit)) {
    if (value1 != null && value2 != null) {
        lambdaParams(value1, value2)
        //lambdaParams(value1, value2).invoke()
    }
}
fun <T1, T2> ifNotNull(value1: T1?, value2: T2?, lambdaParams: () -> (Unit)) {
    if (value1 != null && value2 != null) {
        lambdaParams()
        //lambdaParams().invoke()
    }
}
Kotlin和Groovy等语言一样，支持闭包(block)，如果函数中最后一个参数为闭包，那么最后一个参可以不写在括号中，而写在括号后面，如果只有一个参数，括号也可以去掉。
如下所示：
fun toast() {
    button.setOnClickListener({
       Toast.makeText(context, "test", Toast.LENGTH_SHORT).show()
    })
}

fun toast() {
    button.setOnClickListener {
        Toast.makeText(context, "test", Toast.LENGTH_SHORT).show()
    }
}
用lambda表达式来替换匿名内部类

在lambda中我们遵循如下的表达式来编写：expression = (variable) -> action
variable: 这是一个变量,一个占位符。像x,y,z,可以是多个变量；
action: 这里我称它为action, 这是我们实现的代码逻辑部分,它可以是一行代码也可以是一个代码片段。
可以看到Java中lambda表达式的格式：参数、箭头、以及动作实现，当一个动作实现无法用一行代码完成，可以编写 一段代码用{}包裹起来。
lambda表达式可以包含多个参数,例如：
int sum = (x, y) -> x + y;

面向函数的编程（Functional Programming）是指对于只有一个方法的接口可以使用 Lambda 表达式实现。
为接口引入了一个新的注解：@FunctionalInterface，表示该接口为函数式接口，只允许有一个方法。否则编译器报错。
// 只允许有一个方法。否则编译器报错。  
@FunctionalInterface    
public interface Runnable {  
    public abstract void run();  
}  		
只有一个方法的接口很好的一个例子就是： java.lang.Comparable 接口。
它只有一个方法： compareTo(Object obj)

Lambda Expression ( -> 斜着看 ）
Lambda Expression VS. Anonymous inner class
对于只有一个方法的接口的实现类，写实现类时，只需提供（ 参数 + Lambda + 方法体 ）即可。
// old  
        obj = new A(){  
            public void show(){  
                System.out.println("Hello");  
            }  
        }  
// java 8  
        obj = () -> {  
            System.out.println("Multiple");  
            System.out.println("Lines ... ");  
        }  
// or  
        obj = () -> System.out.println("Single line.");  	
		如果方法只有一个参数，小括号可省略。方块体本身就是一个对象，可以作为参数直接传递。




协程的有什么作用，工作原理是怎样的？
协程中的一些关键名称(例如：Job、Coroutine、Dispatcher、CoroutineContext与CoroutineScope、suspend)它们之间到底是怎么样的关系？
Dispatchers.Default其实是一个CoroutineDispatcher实例
GlobalScope.launch调用的就是CoroutineScope.launch方法，从方法定义可以看到，它返回的是一个Job对象，它可以用来启动或者取消这个协程，查看协程的状态，也可以用来协调多个协程的合作。
GlobalScope.async调用的就是CoroutineScope.async方法，它返回一个Deferred对象，Deferred有一个await方法，这个方法被调用后会暂停调用方协程，直到await结果可用返回或者有异常从中抛出

协程Coroutine：withContext suspend关键字、withContext(Dispatchers.Main){...}
suspend方法只能在suspend方法或者在协程中Coroutine调用。是一个耗时函数的提示。
挂起函数，它不会造成线程阻塞，但是会 挂起 协程，并且只能在协程中使用。
挂起函数不可以在main函数中被调用，那么我们怎么调试呢？对了，就是使用runBlocking 函数！
kotlin中GlobalScope类提供了几个创建协程的构造函数，以下为创建协程的几种方式：
GlobalScope.launch{...}： 创建协程
GlobalScope.async{...}： 创建带返回值的协程，返回的是 Deferred 类
withContext(Dispatchers.Main/IO/Default){...}：不创建新的协程，在指定协程上运行代码块
runBlocking：不是 GlobalScope 的 API，可以独立使用，区别是 runBlocking 里面的 delay 会阻塞线程，而 launch 创建的不会
withContext这个函数主要可以切换到指定的线程，并在闭包内的逻辑执行结束之后，自动把线程切回去继续执行
例如：
coroutineScope.launch(Dispatchers.Main) {      //  在 UI 线程开始
    val image = withContext(Dispatchers.IO) {  // 切换到 IO 线程，并在执行完成后切回 UI 线程
        getImage(imageId)                      // 将会运行在 IO 线程
    }
    avatarIv.setImageBitmap(image)             // 回到 UI 线程更新 UI
} 
Kotlin协程 ——从 runBlocking 与 coroutineScope 说起：runBlocking 是常规函数，而coroutineScope是挂起函数。supervisorScope
runBlocking是阻塞包含runBlocking的线程，阻塞着线程直到runBlocking内的所有协程执行完毕。？
coroutineScope接口及函数
协程与协程之间是存在父子关系的，父协程一定在其子协程结束之后才会结束。也就是说，父协程在执行完自己的代码逻辑后会检测与自己关联的子协程的状态，如果还有子协程没有执行完（这里的没执行完是指协程处于活动状态，也就是isActive返回true的情况。如果isActive返回false则算是执行完了，即使还有代码逻辑在运行。），会一直等到子协程结束才会结束自己。
在runBlocking中直接调用launch方法创建的协程是会建立父子关系，这样runBlocking会等到launch创建的协程执行完才结束，而通过调用GlobalScope.launch方法创建的协程是没有父协程的。

https://www.jianshu.com/p/9398c21b2615
https://blog.csdn.net/xyh269/article/details/90645484

理解Python的协程(Coroutine) - 简书
但是像JS和python这种互联网中流砥柱都是过了一两年才逐渐开始支持。没有async/await，想用同步方式写异步逻辑就只能借助coroutine。

同一时间发起两个甚至多个请求，再把两个结果合并
https://blog.csdn.net/weixin_42954368/article/details/105897083
https://blog.csdn.net/Androiddddd/article/details/109723827
https://www.jianshu.com/p/0ec9c85fbf9b

https://blog.csdn.net/xyh269/article/details/90645484
Kotlin协程 ——从 runBlocking 与 coroutineScope 说起：runBlocking 是常规函数，而coroutineScope是挂起函数。supervisorScope
https://blog.csdn.net/u011133887/article/details/98617852
https://blog.csdn.net/u012503033/article/details/105767054/







