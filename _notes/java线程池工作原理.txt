任务队列，工作队列及(线程队列)交互+双层while循环的线程间通讯(主线程即任务线程，子线程即工作线程)
每个子线程即工作线程都是双层while循环的线程间通讯

启动线程的唯一方法就是通过 Thread 类的 start()实例方法。 start()方法是一个 native 方法，它将启动一个新线程，并执行 run()方法。Thread 类本质上是实现了 Runnable 接口的一个实例，代表一个线程的实例。
创建线程的方式有两种：1、继承Thread类  2、实现Runnable接口

线程池的主要工作是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务。
如果所需线程数量超过了线程池的最大数量那么超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
线程池的主要特点为： 线程复用； 控制最大并发数； 管理线程。

　　1、线程复用原理：
　　　　每一个 Thread 的类都有一个 start 方法。 当调用 start 启动线程时 Java 虚拟机会调用该类的 run方法。 那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 
我们可以继承重写Thread类，在其start方法中添加不断循环调用传递过来的Runnable对象。这就是线程池的实现原理，循环方法中不断获取Runnable是用Queue实现的，在获取下一个Runnable之前可以是阻塞的。

　　2、线程池的组成：
　　　　一般的线程池主要分为以下 4 个组成部分：
　　　　　　1）线程池管理器：用于创建并管理线程池
　　　　　　2）工作线程：线程池中的线程
　　　　　　3）任务接口：每个任务必须实现的接口，用于工作线程调度其运行
　　　　　　4）任务队列：用于存放待处理的任务，提供一种缓冲机制
　　　　调用方不断地向线程池中提交任务形成任务队列；线程池中有一组线程，不断地从队列中取任务，这是一个典型的生产者—消费者模型。
　　　　Java 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor， Executors，ExecutorService， ThreadPoolExecutor ， Callable 和 Future、 FutureTask 这几个类。

　　3、拒绝策略：
　　　　线程池中的线程已经达到线程池设置的max，无法继续为新任务服务，同时等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。
　　　　JDK 内置的拒绝策略如下：
　　　　　　1）AbortPolicy ： 直接抛出异常，阻止系统正常运行。
　　　　　　2）CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。
　　　　　　3）DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。
　　　　　　4）DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。
　　　　以上内置拒绝策略均实现了 RejectedExecutionHandler 接口，若以上策略仍无法满足实际需要，完全可以自己扩展 RejectedExecutionHandler 接口。
　　4、Java 线程池工作过程：
　　　　1）线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。
　　　　2）当调用 execute() 方法添加一个任务时，线程池会做如下判断：
　　　　　　a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；
　　　　　　b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列；
　　　　　　c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；
　　　　　　d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常 RejectExecutionException。
　　　　3）当一个线程完成任务时，它会从队列中取下一个任务来执行。
　　　　4）当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会进行判断：如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。


java中使用Executors创建四种常用的线程池：
1）newCachedThreadPool
创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。
调用 execute 将重用以前构造的线程（如果线程可用）。如果现有线程没有可用的，则创建一个新线程并添加到池中；终止并从缓存中移除那些已有 60 秒钟未被使用的线程。
因此，长时间保持空闲的线程池不会使用任何资源。
2）newFixedThreadPool
创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。
在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。
如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。
3）newScheduledThreadPool
创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。
4）newSingleThreadExecutor
Executors.newSingleThreadExecutor()返回一个线程池（这个线程池只有一个线程） ,这个线程池可以在线程死后（或发生异常时）重新启动一个线程来替代原来的线程继续执行下去！



