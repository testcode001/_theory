http://geekfaner.com/resume/index.html
http://geekfaner.com/shineengine/index.html
https://www.cnblogs.com/yongdaimi/p/11244950.html

EGL10 	   mEgl = (EGL10) EGLContext.getEGL();
EGLDisplay mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
EGLConfig  mEglConfig;
EGLContext mEglContext;
EGLSurface mEglSurface;

使用EGL的绘图的一般步骤：
1、获取 EGL Display 对象：eglGetDisplay()
2、初始化与 EGLDisplay 之间的连接：eglInitialize()
3、获取 EGLConfig 对象：eglChooseConfig()
4、创建 EGLContext 实例：eglCreateContext()
5、创建 EGLSurface 实例：eglCreateWindowSurface()
6、连接 EGLContext 和 EGLSurface：eglMakeCurrent()
7、使用 OpenGL ES API 绘制图形：gl_*()
8、切换 front buffer 和 back buffer 送显：eglSwapBuffer()
9、断开并释放与 EGLSurface 关联的 EGLContext 对象：eglRelease()
10、删除 EGLSurface 对象
11、删除 EGLContext 对象
12、终止与 EGLDisplay 之间的连接

Display(EGLDisplay) 是对实际显示设备的抽象。
Surface（EGLSurface）是对用来存储图像的内存区域。
FrameBuffer 的抽象，包括 Color Buffer， Stencil Buffer ，Depth Buffer。Context (EGLContext) 存储 OpenGL ES绘图的一些状态信息。

EGLSurface 可以是由 EGL 分配的离屏缓冲区（称为“pbuffer”），或由操作系统分配的窗口。EGL 窗口 Surface 通过 eglCreateWindowSurface() 调用被创建。该调用将“窗口对象”作为参数，在 Android 上，该对象可以是 SurfaceView、SurfaceTexture、SurfaceHolder 或 Surface，所有这些对象下面都有一个 BufferQueue。当您进行此调用时，EGL 将创建一个新的 EGLSurface 对象，并将其连接到窗口对象的 BufferQueue 的生产方接口。此后，渲染到该 EGLSurface 会导致一个缓冲区离开队列、进行渲染，然后排队等待消耗方使用。（术语“窗口”表示预期用途，但请注意，输出内容不一定会显示在显示屏上。）
EGL 不提供锁定/解锁调用，而是由您发出绘制命令，然后调用 eglSwapBuffers() 来提交当前帧。方法名称来自传统的前后缓冲区交换，但实际实现可能会有很大的不同。
一个 Surface 一次只能与一个 EGLSurface 关联（您只能将一个生产方连接到一个 BufferQueue），但是如果您销毁该 EGLSurface，它将与该 BufferQueue 断开连接，并允许其他内容连接到该 BufferQueue。
通过更改“当前”EGLSurface，指定线程可在多个 EGLSurface 之间进行切换。一个 EGLSurface 一次只能在一个线程上处于当前状态。
关于 EGLSurface 最常见的一个错误理解就是假设它只是 Surface 的另一方面（如 SurfaceHolder）。它是一个相关但独立的概念。您可以在没有 Surface 作为支持的 EGLSurface 上绘制，也可以在没有 EGL 的情况下使用 Surface。EGLSurface 仅为 GLES 提供一个绘制的地方。

公开的 Surface 类以 Java 编程语言实现。C/C++ 中的同等项是 ANativeWindow 类，由 Android NDK 半公开。您可以使用 ANativeWindow_fromSurface() 调用从 Surface 获取 ANativeWindow。就像它的 Java 语言同等项一样，您可以对 ANativeWindow 进行锁定、在软件中进行渲染，以及解锁并发布。
要从原生代码创建 EGL 窗口 Surface，可将 EGLNativeWindowType 的实例传递到 eglCreateWindowSurface()。EGLNativeWindowType 是 ANativeWindow 的同义词，您可以自由地在它们之间转换。
基本的“原生窗口”类型只是封装 BufferQueue 的生产方，这一点并不足为奇。

OpenGL ES 定义了一个渲染图形的 API，但没有定义窗口系统。为了让 GLES 能够适合各种平台，GLES 将与知道如何通过操作系统创建和访问窗口的库结合使用。用于 Android 的库称为 EGL。如果要绘制纹理多边形，应使用 GLES 调用；如果要在屏幕上进行渲染，应使用 EGL 调用。
在使用 GLES 进行任何操作之前，需要创建一个 GL 上下文。在 EGL 中，这意味着要创建一个 EGLContext 和一个 EGLSurface。GLES 操作适用于当前上下文，该上下文通过线程局部存储访问，而不是作为参数进行传递。这意味着您必须注意渲染代码在哪个线程上执行，以及该线程上的当前上下文。

标准 EGL 数据类型如下所示：
EGLBoolean —— EGL_TRUE =1, EGL_FALSE=0
EGLint —— int 数据类型
EGLDisplay —— 系统显示 ID 或句柄，可以理解为一个前端的显示窗口
EGLConfig —— Surface的EGL配置，可以理解为绘制目标framebuffer的配置属性
EGLSurface —— 系统窗口或 frame buffer 句柄 ，可以理解为一个后端的渲染目标窗口。
EGLContext —— OpenGL ES 图形上下文，它代表了OpenGL状态机；如果没有它，OpenGL指令就没有执行的环境。
下面几个类型比较复杂，通过例子可以更深入的理解。这里要说明的是这几个类型在不同平台其实现是不同的，EGL只提供抽象标准。
NativeDisplayType—— Native 系统显示类型，标识你所开发设备的物理屏幕
NativeWindowType —— Native 系统窗口缓存类型，标识系统窗口
NativePixmapType —— Native 系统 frame buffer，可以作为 Framebuffer 的系统图像（内存）数据类型，该类型只用于离屏渲染。



https://blog.csdn.net/weixin_34080903/article/details/88004050
Context
Context不是什么神秘的东西，它仅仅是一个容器，里面放着两个东西：
1.内部状态信息(View port, depth range, clear color, textures, VBO, FBO, ...)
2.调用缓存，保存了在这个Context下发起的GL调用指令。(OpenGL 调用是异步的)
总的来说，Context是设计来存储渲染相关的输入数据。

Surface
对应的Surface则是设计来存储渲染相关的输出数据。Surface实际上是一个对底层窗口对象的拓展、或是一个有着额外辅助缓冲的像素映射(pixmap)。这些辅助缓存包括颜色缓存(color buffer)、深度缓冲(depth buffer)、模板缓冲(stencil buffer)。

eglMakeCurrent：将EGLDisplay、EGLSurface、EGLContext绑定起来
当发起GL 调用指令(如：glDrawElements)的时候，这个调用会影响到哪个Context和Surface呢？答案就在eglMakeCurrent里。
eglMakeCurrent把context绑定到当前的渲染线程以及draw和read指定的Surface。
draw用于除数据回读(glReadPixels、glCopyTexImage2D和glCopyTexSubImage2D)之外的所有GL 操作。回读操作作用于read指定的Surface上的帧缓冲(frame buffer)。
因此，当我们在线程T上调用GL 指令，OpenGL ES 会查询T线程绑定是哪个Context C，进而查询是哪个Surface draw和哪个Surface read绑定到了这个Context C上。

EGL14.eglSwapBuffers(...)
如果surface是一个双重缓冲surface(大多数情况)，这个方法将会交换surface内部的前端缓冲(front-buffer)和后端缓冲(back-surface)。
后端缓冲用于存储渲染结果，前端缓冲则用于底层窗口系统，底层窗口系统将缓冲中的颜色信息显示到设备上。

-----------------------------------------------------------------------------------------------------------------------------




