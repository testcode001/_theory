https://zhuanlan.zhihu.com/p/28169456
线程栈帧stack frames：
系统为每一个线程分配一个栈。在线程的运行过程当中，执行到一个新的方法调用，就在栈中增加一个内存单元，即帧(frame)。在frame中，保存有该方法调用的参数、局部变量和返回地址。引用的对象保存在堆中。
当某方法运行结束时，该方法对应的frame将会从栈中删除，frame中所有局部变量和参数所占有的空间也随之释放。线程回到原方法继续执行，当所有的栈都清空的时候，程序也就随之运行结束。
https://zhuanlan.zhihu.com/p/34121117
异常信息的堆栈是以线程为单位打印的，打印的调用链也只是当前线程的，即线程栈帧stack frame。
线程切换Handler.sendMessage()/start()、是否需要线程同步
如何检测多线程死锁
Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于性能、稳定性和安全性几方面的原因。
https://zhuanlan.zhihu.com/p/35519585
https://zhuanlan.zhihu.com/p/63509960

进入同步代码块后，释放对象锁只有两种方式：要么代码块执行完，要么调用wait()方法。即便线程的cpu时间片用完，也不会释放对象锁，仍持有该对象锁
释放对象锁只有两种方式：1.synchronized代码块执行完 2.lock调用wait()/wait(long timeout)方法。而线程时间片消耗完或者在线程中调用sleep()方法不会释放对象锁
wait(long timeout)线程wait timeout时间后，进入就绪状态，若要运行则需要再次获得对象锁。
https://blog.csdn.net/z69183787/article/details/88319623
https://blog.csdn.net/weixin_35079766/article/details/112136785
同一进程的不同线程之间可以相互持有访问数据，但不同进程之间不能相互访问数据。

一般高速缓存有3级：L1，L2，L3，CPU 与内存的交互，就发生了变化，CPU 不再与内存直接交互，CPU 会先去 L1 中寻找数据，没有的话，再去 L2 中寻找，然后是 L3，最后才去内存寻找(更准确的来说，应该是 CPU 中的寄存器去寻找)。
但是随着科技的进步，CPU 厂商们叒搞事了，推出了多核 CPU，每个 CPU 上又有高速缓存，CPU 与内存的交互就变成了下面这个样子
保证多线程编程的原子性、可见性以及有序性，他解决了多核CPU缓存一致性、处理器优化和指令重排、并发编程等导致的内存访问问题

https://blog.csdn.net/u013412772/article/details/80109727
要保证多线程并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
【1.原子性】即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
AtomicInteger原子类的工作原理-CAS比较并交换机制
CAS比较并交换(Conmpare And Swap)操作包含三个操作数 – 内存地址、预期值和新值。
CAS 的实现逻辑是将内存地址的数值与预期数值想比较，若相等，则将内存位置处的值替换为新值。若不相等，则不做任何操作。
CAS带来最大问题就是ABA问题。有A、B两个线程，A线程运行10s，B线程运行2s，两个线程同一时间开始运行都修改同一变量m，假设m初始值为5，B线程修改m值5改为10，再修改m值10改为5。
此时A线程修改m值5改为6，修改成功，满足CAS操作原理，而A线程认为m一直都是5，它并不知道m的值已经被修改过。
解决该问题通过添加版本号来解决，每次修改都带着本次修改的版本号，发现版本不是当前版本此修改失败，否则修改成功。如果自旋同理重新获得版本号计算旧值、新值等。
【2.可见性】是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。volatile是无法保证复合操作的原子性。
对于可见性，Java提供了volatile关键字来保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
【3.有序性】即程序执行的顺序按照代码的先后顺序执行。在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性。
指令重排序不会影响单个线程的执行，但是会影响到多线程并发执行的正确性。
指令重排序是处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
指令重排序问题预期而至，这时候祭出终极武器：内存屏障指令，在代码里面禁用缓存。
为了保证内存可见性，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。JMM把内存屏障指令分为下列四类：

running: 1.运行所在线程ID 2.回调顺序 3.是否同一个实例变量
线程之间可以共享数据，进程之间不可以共享数据。
线程切换，新建线程，阻塞线程、终止线程


