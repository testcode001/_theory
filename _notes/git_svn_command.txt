svn命令：
代码下载：svn co repo_url .
更新：svn up [-r version]
添加文件：svn add . --force
删除文件：svn rm
提交：svn ci -m "log"	(需指定SVN_EDITOR环境变量)
先更新后提交(解决冲突)
查看本地已修改的文件内容svn diff -r version1:version2 [path]

下载分支上指定版本的代码：svn co -r version repo_url .
指定分支上代码回滚：
1.下载最新代码并进入相应目录下 2.svn merge -r rHEAD:[要回滚到的版本] repo_url (会产生冲突，解决冲突后，提交) 3.svn ci -m "log"

svn revert	回滚代码：本地已修改但未提交到服务器
svn cat -r version [filename] 显示指定版本的文件内容
svn log | more 查看提交日志
svn st		查看文件或者目录状态
svn info
svn resolved

svn：
http://blog.csdn.net/q199109106q/article/details/8655204
http://blog.csdn.net/ithomer/article/details/6187464
-----------------------------------------------------------------------

常用git命令:
git分布式操作
工作区、本地库(暂存区、版本库)、远端库
git clone repo_url 创建本地仓库 (git init)
git branch -r 查看远程分支
git checkout remoteBranchName/tag_name/ -b localBranchName 检出远程分支
git submodule init
git submodule update
git commit --amend 
git push origin feature-v4:refs/for/feature-v4

git分支管理命令：
git branch -a 查看所有本地和远程分支
创建分支
git branch -b branchName
git branch branchName SHA-1的commit标识 (git log --pretty=oneline)
git branch newBranch oldBranch 创建分支newBranch
git checkout Cb newBranch oldBranch 创建分支newBranch并切换到该分支
切换分支
git checkout localBranchName
合并分支
git merge -m "log" dev 把dev分支合并到master分支(当前在master分支下)。merge即merge from
删除分支
git branch Cd dev2

git status查看已修改的文件
git diff 查看本地已修改的文件?
gitk 查看提交日志
git log --pretty=oneline
git cherry-pick sha-1的commit标识 将某次提交commit应用到当前分支 (该命令可通过git merge或git rebase代替)（倒数第二个需要修改的提交）
git pull origin master --rebase#从服务器更新本地代码库和工作拷贝.
git fetch从服务器更新本地库(但不更新工作拷贝)
git branch 查看本地分支
git checkout localBranchName 切换分支
git checkout -- file.cpp 检出文件(放弃对文件的修改)
git checkout . 抛弃工作区修改
git add . 
git rm -rf
git commit -a -m "log" #提交到本地库
git commit --amend 修改上次的提交
git push origin(repo_url) localBranchName:remoteBranchName #提交远端库
git push origin :test  删除远程分支 :左边的分支为空
先更新，后提交。解决冲突：git mergetool执行用预先配置的Beyond Compare解决冲突; git commit
git checkout ${commit} /path/to/file  检出指定版本的某个文件夹
下载分支上指定版本的代码
git reset --hard HEAD^         回退到上个版本
git reset --hard HEAD~3        回退到前3次提交之前，以此类推，回退到n次提交之前
git reset --hard commit_id     退到/进到 指定commit的sha码
git reset --hard sha-1值前6位 代码回滚到指定版本
强推到远程：
git push origin HEAD --force

git stash [push -m "msg"]				#保存当前工作进度，会把暂存区和工作区的改动保存起来。执行完这个命令后，在运行git status命令，就会发现当前是一个干净的工作区，没有任何改动。使用git stash save 'message...'可以添加一些注释
git stash list							#显示保存进度的列表。也就意味着，git stash命令可以多次执行。
git stash pop [Cindex] [stash_id]
git stash pop --index 					#恢复最新的进度到工作区和暂存区。（尝试将原来暂存区的改动还恢复到暂存区）
git stash pop stash@{1}					#恢复指定的进度到工作区。stash_id是通过git stash list命令得到的 通过git stash pop命令恢复进度后，会删除当前进度。
git stash apply [Cindex] [stash_id]		#除了不删除恢复的进度之外，其余和git stash pop 命令一样。
git stash drop [stash_id]				#删除一个存储的进度。如果不指定stash_id，则默认删除最新的存储进度。
git stash clear							#删除所有存储的进度。

git tag和git log的功能差不多，都是用于版本回退，但新功能开发或紧急bug的提交只能新建branch来完成。即新建branch的功能大于git tag
from..to..
创建.关联.删除远程分支：
git push origin 本地branch:远程branch
git pull origin <远程branch>:<本地branch>
git branch --set-upstream-to=origin/<远程branch> 本地分支
git push origin :远程branch
创建.切换.merge.删除本地分支
git checkout -b 本地分支名
git merge 其他branch  或者git cherry-pick commitId  将其他分支合并到当前分支
git branch CD 本地分支名
检出远程指定分支：
git pull
git checkout -b 本地分支名 origin/远程分支名  或者git checkout 远程分支名，git会自动关联

查看标签,打印所有标签
git tag
打印符合检索条件的标签
git tag -l 1.*.*
查看对应标签状态
git checkout 1.0.0
创建标签(本地)
创建轻量标签
git tag 1.0.0-light
创建带备注标签(推荐)
git tag -a 1.0.0 -m "这是备注信息"
针对特定commit版本SHA创建标签
git tag -a 1.0.0 0c3b62d -m "这是备注信息"
将本地标签发布到远程仓库, 发送所有
git push origin --tags
指定版本发送
git push origin 1.0.0
删除标签(本地)
git tag -d 1.0.0
删除远程仓库对应标签
Git版本 > V1.7.0
git push origin --delete 1.0.0
旧版本Git
git push origin :refs/tags/1.0.0
	
git生成patch文件和打patch：
git format-patch：生成patch
git format-patch HEAD^ 　　　　　　　　　　　　　   #生成最近的1次commit的patch
git format-patch HEAD^^　　　　　　　　　　　　　  	#生成最近的2次commit的patch
git format-patch HEAD^^^ 　　　　　　　　　　　　　	#生成最近的3次commit的patch
git format-patch HEAD^^^^ 　　　　　　　　　　　    #生成最近的4次commit的patch
git format-patch <r1>..<r2>                       	#生成两个commit间的修改的patch（包含两个commit. <r1>和<r2>都是具体的commit号)
git format-patch -1 <r1>                            #生成单个commit的patch
git format-patch <r1>                               #生成某commit以来的修改patch（不包含该commit）
git format-patch --root <r1>　　　　　　　　　　　　#生成从根到r1提交的所有patch
git am：打patch
git apply --stat 0001-limit-log-function.patch   　 # 查看patch的情况
git apply --check 0001-limit-log-function.patch   　# 检查patch是否能够打上，如果没有任何输出，则说明无冲突，可以打上
(注：git apply是另外一种打patch的命令，其与git am的区别是，git apply并不会将commit message等打上去，打完patch后需要重新git add和git commit，
而git am会直接将patch的所有信息打上去，而且不用重新git add和git commit,author也是patch的author而不是打patch的人)
git am 0001-limit-log-function.patch                # 将名字为0001-limit-log-function.patch的patch打上
git am --signoff 0001-limit-log-function.patch      # 添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者
git am ~/patch-set/*.patch　　　　　　　　　　　　　# 将路径~/patch-set/*.patch 按照先后顺序打上
git am --abort                              		# 当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)
git am --resolved                           		#当git am失败，解决完冲突后，这条命令会接着打patch
 

git rebase 阮一峰  廖雪峰
rebase操作可以把本地未push的分叉提交历史整理成直线；即对本地未push的commit的CRUD操作
git diff
git log、git reflog
git tag
查看配置：
git config [Clocal|Cglobal|Csystem] -l
修改配置：
$ git config --global user.name "yourname"
$ git config --global user.email "yourname@gmail.com"
添加配置：
git Cadd section.key value(默认是添加在local配置中)
.git/config仓库级配置文件local
~/.gitconfig 全局级配置文件global
./etc/gitconfig 系统级配置文件system



