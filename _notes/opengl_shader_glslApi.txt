shader脚本熟练
顶点坐标系和纹理坐标系是有严格的顺序的，且顺序一定要保持一致***。(顶点坐标系(画布).纹理坐标系(画本身)， 顶点着色器shader(定义画布容器及画的范围).片段着色器shader(具体绘制画的像素))
(可以为正"z"或者反"z"字的顺序，取决于最后GLES20.glDrawArrays(GLES20.GL_TRIANGLE_STRIP,0,4);的参数类型) 
oes纹理的纹理坐里标系和普通sampler2D的纹理坐标系不一样，要做一定旋转或者对称处理。
纹理坐标系是有严格的顺序的，顺时针或者逆时针旋转时是以正中心为锚点，旋转90,180,270度等。左右或者上下翻转时也是以中心进行坐标对称。
OpenGl的和纹理和绘制.资源释放相关的操作必须运行在GL线程中，而不能运行在其他线程。
滤镜shader的坐标顺序一定要和顶点坐标和纹理坐标保持一致
顶点坐标的取值范围是-1到1， 0.0坐标在正中间。纹理坐标的取值范围值0到1，0.0坐标在左下角。
shader脚本注释符是//而不是#。实际开发的时候尽量不要在着色器代码中添加注释，防止出现编译错误。shader脚本注释加了英文注释能运行，但是加了中文注释就不能运行。
矩阵与矩阵加减乘除、向量与向量加减乘除、矩阵与向量加减乘除
矩阵相乘即左行乘右列, 结果左列右行。矩阵与向量相乘，结果为向量。
矩阵乘法的本质是什么？
https://www.zhihu.com/question/21351965?sort=created

shader：
attribute或者gl_Position一定是顶点着色器，gl_FragColor或者precision medium float;一定是片段着色器。gl_Position和gl_FragColor都是为vec4的矢量。
获取顶点shader脚本中的attribute属性，并赋值于定点坐标和纹理坐标，并将坐标传递给片段shader。获取片段shader脚本中的uniform属性/uniform纹理属性，并赋值于纹理更新后的matrix矩阵/明确指定采样的纹理层级等。
顶点shader中坐标的数据类型都是attribute vec4，片段shader中纹理的数据类型是uniform sampler2D或者uniform samplerExternalOES视频帧纹理(实际问int类型，调用GLES20.glUniform1i(glUniformTexture, 0);来赋值)。
顶点着色器shader：顶点坐标和纹理坐标内存申请及赋值。
纹理着色器shader：普通绘制，图片sampler2D只需要纹理坐标，不需要纹理采样矩阵。视频OES需要纹理采样矩阵。
vec4 currentPixelPosition = texMatrix * vertexCoordinate;   			gl_Position = currentPixelPosition;
vec4 currentPixelColor = texture2D(vTexture,aCoordinate);	gl_FragColor =currentPixelColor; //texture2D()内置函数对纹理的指定坐标点的颜色采样
定点着色器shader即对一个像素中W.X.Y.Z四通道数值的修改currentPixelPosition.xyzw取值范围[-1,1]。 定点shader要把纹理坐标系要通过定点shader中的varying属性传递给片段shader中的varying属性
片段着色器shader即对一个像素中R.G.B.A四通道数值的修改currentPixelColor.rgba取值范围[0,1]，或者对纹理坐标系textureCoordsVarying.xy取值范围[0,1]的修改。
确定取值范围，归一"1"化处理：即把取值范围映射到[0,1]或者[-1,1]的范围内
片段shader中rgb通道全是0则为黑色，全为1则为白色，0.5相当于颜色值[0,255]中的128。

LSL脚本： 修饰符，数据类型，内置变量，内置函数texture2D().mix()
【shader修饰符及数据类型】
【修饰符】
attribute数据类型只能用在vertexShader中，且只能用来修饰float标量(只有大小没有方向)、float向量以及矩阵变量，不能用来修饰其他类型的变量。用来定义如顶点位置、纹理坐标、法向量、颜色等等。
uniform用于定义全局变量，在一个像素绘制过程中是一个常量。用来定义如光源位置、统一变换矩阵、颜色等。
varying用于vertexShader向fragmentShader传递数据
const	用于声明常量
内置变量gl_Position和gl_FragColor都是vec4类型的向量，可通过 x.y.z.w和r.g.b.a来访问各个分量。
顶点着色器中的内建变量还有gl_PointSize 该值一般只有在采用了点绘制方式后才有意义。
片元着色器中的内建变量还有gl_FragCoord 和 gl_FrontFacing，这两个都是只读的，由渲染管线中片元着色器之前的阶段生成。
gl_FragCoord是一个vec4类型，其含有当前片元相对于窗口位置的坐标值 x、y、z 与 1/w 。其中 x 与 y 分别为片元相对于窗口的二维坐标，z 部分为该片元的深度值。
通过该内建变量可以实现与窗口位置相关的操作，例如，仅绘制窗口中指定区域内容等。
gl_FrontFacing 是一个布尔类型的内建变量，通过读取该内建变量的值可以判断正在处理的片元是否属于在光栅化阶段生成此片元的对应图元的正面。
如果属于正面，gl_FrontFacing的值为true，反之为false 。
【数据类型】
int
float
bool
vec2为矢量
vec3为矢量
vec4为矢量
mat2为矩阵
mat3为矩阵
mat4为矩阵
gl_Position和gl_FragColor都是为vec4的矢量
sampler1D：1D图片纹理
sampler2D：2D图片纹理
samplerExternalOES：视频帧纹理
sampler3D：3D图片纹理
sampleCube：立方贴图纹理
使用struct关键字声明类C的结构体
在GLSL中，可以声明任何类型的数组：vec3 position[20];
【search：GLSL内置函数及内置变量】
https://www.jianshu.com/p/9f5b8ffe7771
变量名不能以数字开头，还有变量名不能以gl_作为前缀，这个是GLSL保留的前缀，用于GLSL的内部变量。
all：在所有为真的时候，返回为真；
any：在任一变量为真的时候，返回为真；
dot：向量点乘
cross：向量的叉积
ceil(x)：向上取整 如：ceil(3.5) 值为4
floor(x)：向下取整 如：floor(3.5) 值为3
pow(x,y)：求x的y次方
exp(x)：自然指数e的x次方
exp2(x)：2的x次方
transpose：矩阵求转置矩阵
determinant：求行列式
inverse：矩阵求逆矩阵
distance：计算两点的距离
length：求解向量的长度
normalize：对一个向量进行标准化
clamp：将一个值截取到两个值之间
matrixCompMult：在两个矩阵之间执行一个逐分量的操作
outerProduct：提取两个向量的外积，这个函数的作用就是将一个n*1的向量与1*m的向量相乘，得到一个n*m的矩阵
一般默认都用弧度；
radians(degree) : 角度变弧度；
degrees(radian) : 弧度变角度；
sin(angle), cos(angle), tan(angle)
asin(x): arc sine, 返回弧度 [-PI/2, PI/2];
acos(x): arc cosine,返回弧度 [0, PI];
atan(y, x): arc tangent, 返回弧度 [-PI, PI];
atan(y/x): arc tangent, 返回弧度 [-PI/2, PI/2];
pow(x, y): x的y次方；
exp(x): 指数, log(x)：
exp2(x): 2的x次方， log2(x):
sqrt(x): x的根号； inversesqrt(x): x根号的倒数
abs(x): 绝对值
sign(x): 符号, 1, 0 或 -1
floor(x): 底部取整
ceil(x): 顶部取整
fract(x): 取小数部分
mod(x, y): 取模， x - y*floor(x/y)
min(x, y): 取最小值
max(x, y): 取最大值
clamp(x, min, max):  min(max(x, min), max);
step(edge, x): 如 x
smoothstep(edge0, edge1, x): threshod  smooth transition时使用。 edge0<=edge0时为0.0， x>=edge1时为1.
length(x): 向量长度
distance(p0, p1): 两点距离， length(p0-p1);
dot(x, y): 点积，各分量分别相乘 后 相加
cross(x, y): 差积，x[1]*y[2]-y[1]*x[2], x[2]*y[0] - y[2]*x[0], x[0]*y[1] - y[0]*x[1]
normalize(x): 归一化， length(x)=1;
faceforward(N, I, Nref): 如 dot(Nref, I)< 0则N, 否则 -N
reflect(I, N): I的反射方向， I -2*dot(N, I)*N, N必须先归一化
refract(I, N, eta): 折射，k=1.0-eta*eta*(1.0 - dot(N, I) * dot(N, I)); 如k<0.0 则0.0，否则 eta*I - (eta*dot(N, I)+sqrt(k))*N
matrixCompMult(matX, matY): 矩阵相乘, 每个分量 自行相乘， 即 r[i][j] = x[i][j]*y[i][j];   矩阵线性相乘，直接用 * 
lessThan(vecX, vecY): 向量 每个分量比较 x < y
lessThanEqual(vecX, vecY): 向量 每个分量比较 x<=y
greaterThan(vecX, vecY): 向量 每个分量比较 x>y
greaterThanEqual(vecX, vecY): 向量 每个分量比较 x>=y
equal(vecX, vecY): 向量 每个分量比较 x==y
notEqual(vecX, vexY): 向量 每个分量比较 x!=y
any(bvecX): 只要有一个分量是true， 则true
all(bvecX): 所有分量是true， 则true
not(bvecX): 所有分量取反
mix(x, y, a): x, y的线性混叠， x(1-a) + y*a;
texture2D(sampler2D, coord): texture lookup
texture2D(sampler2D, coord, bias): LOD bias, mip-mapped texture
texture2DProj(sampler2D, coord):
texture2DProj(sampler2D, coord, bias):
texture2DLod(sampler2D, coord, lod):
texture2DProjLod(sampler2D, coord, lod):
textureCube(samplerCube, coord):
textureCube(samplerCube, coord, bias):
textureCubeLod(samplerCube, coord, lod): 
https://blog.csdn.net/q1398284020/article/details/80181803
https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/
http://docs.gl/sl4/exp2
-----------------------------------------------------------------------------------------------------------------------------

https://blog.csdn.net/wangyantaozzu/article/details/103768279
https://github.com/WangYantao/android-camera-demos/blob/master/android-camera2%E7%9B%B8%E6%9C%BA%E5%BC%80%E5%8F%91%E3%80%908%E3%80%91-%E4%BD%BF%E7%94%A8opengl%E5%AE%9E%E7%8E%B0%E6%BB%A4%E9%95%9C%E6%95%88%E6%9E%9C%EF%BC%881%EF%BC%89.md
给图像添加滤镜本质上就是图片处理，也就是对图片的像素进行计算，简单来说，图像处理的方法可以分为三类：
1.点算子：当前像素的处理只和自身的像素值有关，和其他像素无关，比如灰度处理。
2.邻域算子：当前像素的处理需要和相邻的一定范围内的像素有关，比如高斯模糊。
3.全局算子：在全局上对所有像素进行统一变换，比如几何变换。

灰度滤镜
灰度滤镜通过图像的灰度化算法进行实现。
在 RBG颜色模型中，让 R=G=B=grey， 即可将彩色图像转为灰度图像，其中 grey 叫做灰度值。
grey的计算方法有四种：分量法，最大值法，平均值法、加权平均法。
分量法
使用彩色图像的某个颜色分量的值作为灰度值。
grey=R：R分量灰度图
grey=G：G分量灰度图
grey=B：B分量灰度图
最大值法
将彩色图像三个颜色分量中值最大的作为灰度值。grey = max(R,G,B)
平均值法
将彩色图像的三个颜色分量值的平均值作为灰度值：grey = (R+G+B)/3
加权平均法
在 RGB 颜色模型中，人眼对G（绿色）的敏感度最高，对B（蓝色）的敏感的最低，所以对彩色图像的三个颜色分量做加权平均计算灰度值效果比较好。grey = 0.3R + 0.59G + 0.11*B
下面在片段着色器中用加权平均法实现灰度滤镜。

黑白滤镜
黑白滤镜就是将图像进行二值化处理，彩色图像的颜色值经过处理之后，要么是 0（黑色），要么是255（白色）。
二值化方法主要有：全局二值化，局部二值化，局部自适应二值化。最影响效果的就是阈值的选取。
全局二值化是选定一个阈值，然后将大于该阈值的颜色值置为255，小于该阈值的颜色置为0。因为使用的全局阈值，所以会丧失很多细节。
局部二值化：为了弥补全局阈值化的缺陷，将图像分为N个窗口，每个窗口设定一个阈值，进行二值化操作，一般取该窗口颜色值的平均值。
局部自适应二值化：局部二值化的阈值选取方法仍然不能很好的将对应窗口的图像进行二值化，在此基础上，通过窗口颜色的平均值E、像素之间的差平方P、像素之间的均方根Q等能够表示窗口内局部特征的参数，设定计算公式计算阈值。

反色滤镜
RGB 颜色值的范围是 [0,255]，反色滤镜的的原理就是将 255 与当前颜色的每个分量Rs,Gs,Bs值做差运算。
结果颜色为 (R,G,B) = (255 - Rs, 255 - Gs, 255 - Bs);

亮度滤镜即美白滤镜
增加亮度有两种方法：
1.再 rgb 颜色空间下，将各个颜色分量都加上一个值，可以达到图像亮度增加的目的，但是这种方式会导致图像一定程度上偏白。
2.将颜色值从 rgb 颜色空间转换到 hsl 颜色空间上，因为 hsl(色度Hue.饱和度Saturation.亮度Lightness)更适合视觉上的描述，色度、饱和度、亮度，调整 l（亮度分量），即可实现图像的亮度处理，然后将调整后的 hsl 值再转换到 rgb 颜色空间上进行输出。
搜索：hsl  色度 饱和度 亮度
//rgb转hsl
vec3 rgb2hsl(vec3 color){
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(color.bg, K.wz), vec4(color.gb, K.xy), step(color.b, color.g));
    vec4 q = mix(vec4(p.xyw, color.r), vec4(color.r, p.yzx), step(p.x, color.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

//hsla转rgb
vec3 hsl2rgb(vec3 color){
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(color.xxx + K.xyz) * 6.0 - K.www);
    return color.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), color.y);
}

//亮度
void light(inout vec4 color){
    vec3 hslColor = vec3(rgb2hsl(color.rgb));
    hslColor.z += 0.15;
    color = vec4(hsl2rgb(hslColor), color.a);
}
各颜色空间转换方法：
http://www.easyrgb.com/en/math.php

色调分离
色调分离的原理简单来说就是根据图像的直方图，将图像分为阴影、中间、高光三个部分，在hsl颜色空间中调整每个部分的色相、饱和度。调整色相可以对图像进行色彩调整，调整饱和度可以使图像整体的颜色趋于一个整体的风格。
//色调分离
void saturate(inout vec4 color){
    //计算灰度值
    float grayValue = color.r * 0.3 + color.g * 0.59 + color.b * 0.11;
    //转换到hsl颜色空间
    vec3 hslColor = vec3(rgb2hsl(color.rgb));
    //根据灰度值区分阴影和高光，分别处理
    if(grayValue < 0.3){
        //添加蓝色
        if(hslColor.x < 0.68 || hslColor.x > 0.66){
            hslColor.x = 0.67;
        }
        //增加饱和度
        hslColor.y += 0.3;
    }else if(grayValue > 0.7){
        //添加黄色
        if(hslColor.x < 0.18 || hslColor.x > 0.16){
            hslColor.x = 0.17;
        }
        //降低饱和度
        hslColor.y -= 0.3;
    }
    color = vec4(hsl2rgb(hslColor), color.a);
}

https://www.jianshu.com/p/59edd56c0072
颠倒滤镜:
看过我之前关于纹理翻转的文章的同学应该知道怎么实现了吧，超级简单，只需要将片源着色器中纹理的方向根据你想要颠倒的方向取反。
我们演示的是上下颠倒，所以对纹理的Y坐标取反即可。我们看下代码：
precision highp float;
uniform sampler2D Texture;
varying vec2 TextureCoordsVarying;

void main (void) {
    vec4 color = texture2D(Texture, vec2(TextureCoordsVarying.x, 1.0 - TextureCoordsVarying.y));
    gl_FragColor = color;
}

马赛克滤镜:
precision mediump float;
//纹理坐标
varying vec2 TextureCoordsVarying;
//纹理采样器
uniform sampler2D Texture;
//纹理图片size
const vec2 TexSize = vec2(500.0, 500.0);
//马赛克size
const vec2 mosaicSize = vec2(16.0, 16.0);

void main()
{
    //计算图像的实际位置
    vec2 intXY = vec2(TextureCoordsVarying.x*TexSize.x, TextureCoordsVarying.y*TexSize.y);
    // floor (x) 内建函数,返回小于/等于X的最大整数值.
    // floor (intXY.x / mosaicSize.x) * mosaicSize.x 计算出一个⼩小⻢赛克的坐标.
    vec2 XYMosaic = vec2(floor(intXY.x/mosaicSize.x)*mosaicSize.x, floor(intXY.y/mosaicSize.y)*mosaicSize.y);
    //换算回纹理坐标
    vec2 UVMosaic = vec2(XYMosaic.x/TexSize.x, XYMosaic.y/TexSize.y);
    //获取到马赛克后的纹理坐标的颜色值
    vec4 color = texture2D(Texture, UVMosaic);
    //将⻢赛克颜色值赋值给gl_FragColor. 
    gl_FragColor = color;
}


美颜原理
磨皮：本质就是让像素点模糊，可以使用高斯模糊，但是可能导致边缘会不清晰，用双边滤波(Bilateral Filter) ，有针对性的模糊像素点，能保证边缘不被模糊。
美白：本质就是提高亮度。
红润：本质就是改变色调。
-------------------------------------------------------------------------------------------------------------------------------------------------------

shader教程：顶点着色器和片段着色器是用叫GLSL的类C语言写成的，它包含一些针对向量和矩阵的操作。
https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/
opengl shader内置函数
https://blog.csdn.net/u010607947/article/details/76431474?utm_source=blogxgwz5	

setEGLContextClientVersion(3); // Pick an OpenGL ES 2.0 context.
OpenGL ES 3.0中将2.0的attribute改成了in，顶点着色器的varying改成out，片段着色器的varying改成了in，也就是说顶点着色器的输出就是片段着色器的输入，另外uniform跟2.0用法一样
in或者out变量等不能在函数内（如main函数内）声明
OpenGL ES 2.0的gl_FragColor和gl_FragData在3.0中取消掉了，需要自己定义out变量作为片段着色器的输出颜色，如 out vec4 fragColor;。gl_Position还存在
OpenGL ES 3.0的shader中没有texture2D和texture3D等了，全部使用texture替换












