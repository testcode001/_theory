将demo放于cocos2d-x目录的project目录下，VS打开并运行

cocos2d-x工程编译：
1.创建工程
2.编译.链接：编辑Android.mk文件 即makefile文件	(cygwin环境下运行build_native.sh脚本编译, 使用ndk交叉编译工具)
3.拷贝java库运行：jni调用.so库



http://www.cocos.com/doc/article/index?type=wiki&url=/doc/cocos-docs-master/manual/framework/native/wiki/how-to-start-a-new-cocos2d-x-game/zh.md

Cocos2d-x场景生命周期
http://www.cxyclub.cn/n/45960/
http://www.2cto.com/kf/201406/306087.html
以Scene为基本显示单位
Sprite必须添加到Layer中，Layer必须添加到Scene中
设置Sprite的Position和Action
设置layer的z轴位置
背景层
动画层：页面绘制、坐标检测与转换
事件处理层

图层构成画面：创建图层.创建精灵...、setPosition(ccp(...))、addChild  ()
图层用来划分模块并处理事件响应
图层的默认坐标和大小？
EAGLView相当于一个窗口
游戏引擎：起一个定时器每隔1/60秒刷新一下屏幕	(EAGLView使用了opengl es来画图，速度快，效率高)
坐标转换：
UI坐标系<---->世界坐标系(OpenGL坐标系)<---->图层坐标系<---->锚点坐标系
setPosition(ccp(...))时，注意锚点默认值：图层锚点的默认值是(0, 0)，精灵锚点的默认值是(0.5f，0.5f)	(锚点的属性：1.坐标 2.缩放)
画出精灵图像：1.确定坐标 2.根据锚点值画出精灵图像
都是用sprite1的坐标去加减sprite2的坐标，针对本地坐标系就用减法，针对世界坐标系就用加法。
字体类：
CCLableTTF、CCLableBMFront、CCLableAtlas
cocos2d-x的UI控件库
菜单scene、游戏scene(游戏背景层、精灵层、触摸层)、结束scene
CCSprite是一个具备动作行为的二维纹理图片。
画出精灵对象：
1.确定坐标
2.根据锚点值画出精灵对象。	(锚点的默认值是(0.5f, 0.5f))  锚点代表图片的缩放和位置
一个plist文件(xml文件)对应一个png图片。(红孩儿工具箱、Zwoptex、TexturePacker)
CCSpriteFrameCache加载plist文件  (全局缓存)
CCSpriteFrame
CCSpriteBatchNote加载png图片
动作.动画：
创建精灵、创建动作，精灵运行动作
设置精灵tag属性
CCAction的子类：
即时动作CCActionInstant：
Place
Hide
Show
CCFlipX水平翻转 
onFlipY垂直翻转
CCCallFunc家族：回调函数 
  
持续动作CCActionInterval：平移.缩放.旋转.明暗
移动到 – CCMoveTo
移动– CCMoveBy
跳跃到 – CCJumpTo   设置终点位置和跳跃的高度和次数。
跳跃 – CCJumpBy   设置终点位置和跳跃的高度和次数。
贝塞尔 – CCBezierBy  支持 3 次贝塞尔曲线:P0-起点,P1-起点切线方向,P2-终点切线方向,P3-终点。
放大到 – CCScaleTo   设置放大倍数,是浮点型。
放大 – CCScaleBy
旋转到 – CCRotateTo
旋转 – CCRotateBy
变暗到 – CCFadeTo
由无变亮 – CCFadeIn
由亮变无 – CCFadeOut
闪烁 – CCBlink   设定闪烁次数
色调变化到 – CCTintTo
色调变换 – CCTintBy

组合动作：
序列动作CCSequence.
同步动作CCSpawn、
重复动作CCRepeat.CCRepeatForever、
延时动作CCDelayTime、
Reverse反向动作
变速动作CCActionEase：
CCEaseAction和 CCSpped
EaseIn 由慢至快。
EaseOut 由快至慢
EaseInOut 由慢至快再由快至慢。
EaseSineIn
由慢至快。
EaseSineOut 由快至慢
EaseSineInOut 由慢至快再由快至慢。
EaseExponentialIn 由慢至极快。
EaseExponentialOut 由极快至慢。
EaseExponentialInOut 由慢至极快再由极快至慢。
Speed 人工设定速度,还可通过 SetSpeed 不断调整。

2.动画动作：CCAnimate、CCAnimation动画动作支持反向动作
类似gif的帧动画：几张图片连续播放的动画
Tween补间动画：一张图片的平移.缩放.旋转.明暗动画

3.CCAction的直接子类CCSpeed、CCFollow
4.扩展动作：3D动作类CCGridAction及其子类
动作接口： 
http://labs.easymobi.cn/?p=1687

游戏的生命周期：applicationDidFinishLaunching()、pause().applicationDidEnterBackground()、applicationWillEnterForeground().resume()
CCScene的生命周期：onEnter、onEnterTransitionDidFinish、onExit、onExitTransitionDidStart	(每个方法中必须调用父类同名的方法，以避免丢失触碰信息和内存泄露)
CCLayer的生命周期：onEnter、onEnterTransitionDidFinish、onExit	(每个方法中必须调用父类同名的方法，以避免丢失触碰信息和内存泄露)


定时器
1CCNode对象的schedule、unschedule方法
2.CCTimer

事件处理.即回调函数的触发
cocos2d-x观察者模式
(消息传递机制、消息处理机制)
1.CCTouchDispatcher主要派生的有三个类：CCLayer、CCTargetedTouchDelegate单点触摸、CCStandardTouchDelegate多点触摸
每一个CCNode对象都可以具有触摸事件机制
2.菜单点击后的回调函数
3.动作执行完成后的回调函数

接收CCTouch、分发CCTouchDispatcher、处理CCTouchDelegete	(CCLayer与用户交互相关的函数)
touchesBegin
touchesMove
touchesEnd
touchesCanceled

加速度计处理,如摇晃手机来控制左右方向
CCAccelerometer
CCAccelerometerDelegete

CCLayer的触摸事件
CCMenu->CCLayer->CCNode
CCMenuItem
CCMenuItemFont、CCMenuItemImage

virtual void onEnter();//初始化函数 利用导演类注册代理函数
virtual void onExit();//这里不像CCLayer 我们需要手动注销代理函数
void Paddle::onEnter()
{
    CCDirector* pDirector = CCDirector::sharedDirector();
    pDirector->getTouchDispatcher()->addTargetedDelegate(this, 0, true);
    CCSprite::onEnter();
}
void Paddle::onExit()
{
    CCDirector* pDirector = CCDirector::sharedDirector();
    pDirector->getTouchDispatcher()->removeDelegate(this);
    CCSprite::onExit();
}
CCDirector用来切换场景、获取事件分发器、获取屏幕大小。	(单例模式，采用了队列方式来管理CCScene)
CCSize visibleSize = CCDirector::sharedDirector()->getVisibleSize();
visibleSize.width
visibleSize.height

碰撞检测：
1.碰撞后的回调函数
2.定时器实时检测碰撞
矩形判断.碰撞检测：
矩形包含点、矩形碰撞检测、矩形包含矩形
两个物体必须在同一层上？障碍物以与背景层相同的速度速度向后移动
AABB碰撞检测规则：将两个物体的坐标投影在坐标系中，只有在两个坐标轴都发生重叠的情况下，两个物体才意味着发生了碰撞。

粒子效果：
1.CCTextureCache初始化一张图片
2.粒子编辑器ParticleDesigner：产生一个plist文件。

粒子对象、粒子池、发射器、衰减器
CCParcitleSystem
使用CCParcitleSystemQuad的直接子类来实现粒子效果。
粒子的生命周期：
发射器的作用：初始化及设置粒子的属性
发射器分为重力模式Gravity和半径模式Radius，可通过修改CCParcitleSystem对象的emitterMode属性来选择发射器类型。
开发者必须清楚地知道发射器的每个属性的作用，才能够通过设置得到想要的效果。
粒子效果编辑器：导出一个plist文件(/一张纹理图片)，用代码加载来实现粒子效果。
通常在游戏主题完成之后，再来添加粒子效果。 

关卡用json文件来表示
贝塞尔曲线
界面间数据传递
CCDrawingPrimitives专门用来调试游戏用的

地图制作.背景音乐：
CCTMXTiledMap：读取并解析tmx文件
CCTMXObjectGroup
CTMXLayer
地图编辑器.tmx文件、动画编辑器*SpriteX、MotionWelder、红孩儿工具箱
游戏背景类型：
1.横屏滚动、竖屏滚动
2.斜45°视角
3.俯视
多层背景滚动效果CCParallaxNode

背景音乐采用mp3格式，音效采用ogg格式，使用SimpleAudioEngine类来控制(单例模式)

物理引擎Box2D：
Box2D世界中的物体分为静态物体如大地、动态物体如小鸟.子弹等
在cocos2d世界中创建一个对象后，在Box2D世界中也要创建一个相对应的对象
b2World---->b2Fixture---->属性、b2Shape

OpenGL ES画线
-----------------------------------------------
CCNode：
是一个显示对象，具有显示对象的属性
CCNode还有三个明显的特点：
1.容器作用，可包含CCNode对象作为子节点。对应方法为addChild、getChildByTag、removeChild
2.CCNode对象都可以调用定时器。对应方法为schedule、unschedule
3.CCNode对象都可以执行动作。对应方法为runAction、stopAction
添加子节点时，若当前节点处于运行状态，则会立即调用onEnter和onEnterTransitionDidFinish方法。
CCNode与坐标转换相关的函数、与碰撞检测相关的函数。
CCNode与场景转换相关的函数：

定时器即周期性执行的回调函数。启动.暂停.恢复.取消定时器
游戏逻辑就是在定时器的回调函数中实现的。

创建动作，并让CCNode运行。
当一个CCNode对象销毁时，引擎首先会停止它的所有动作及定时器。
每个CCNode对象都有一个CCCamera对象，CCCamera只是用来增加3D效果。

CCScene:
每个CCNode节点都只有一个父节点，但可有多个子节点(CCNode提供了更改父节点的函数setParent())
当父节点被绘制在界面中时，其拥有的所有子节点也将被绘制在界面中。所以若要显示一个CCNode子节点，则需要将其加入当前场景对象的链表关系中
当游戏中进行场景切换时，内存中会留有两个场景对象，开发者需避免在场景切换时导致内存不足的情况。

CCLayer：
作用：建立与用户的交互功能，如触屏、重力加速度、按键等
默认情况下，图层是不接受用户操作的，开发者需要显式调用函数来开启图层接收用户操作，如setTouchEnabled、setAccelerometerEnabled、setKeypadEnabled
图层是由远及近的顺序来绘制，而信息传递则是由近及远。
每一个图层可以包含文本Lable、按钮button、精灵sprite、地图TileMap
---------------------------------------
网络通信：
POSIX的多线程技术:多线程同步、线程池、定时器
c++中使用curl库来实现http通信
c++中支持Socket通信的第三方库有很多，但都是基于BSD Socket接口实现的。

文件操作模块：
文件读取只是用了一个类CCFileUtils来实现功能。(单例模式)
CCUserDefault用来保存用户数据至xml文件中。(单例模式)
CCRenderTexture用来保存绘制纹理时产生的图片，支持PNG和jpg两种保存格式。

内存管理
http://v.youku.com/v_show/id_XNTk1MjUzMjgw.html

兔子大战转基因：
http://my.oschina.net/arthas/blog/100062



-------------------------------------------------------------------------
c++编译.链接：
java的编译器只有sun一家的， 而c++的编译器有多个版本
所以java的实现标准统一，而c++有多个不同的实现？

c++标准只有声明，没有实现？由各个编译器实现？
http://www.cplusplus.com/reference/cstring/
http://libcxx.llvm.org/

c标准委员会和C++标准委员会
各大编译器厂商都会以它的标准为设计编译器。只有符合ANSI标准的基础下，各自厂商才可以对各语言进行扩展。

Standard C++基金会
https://isocpp.org/


编译环境问题：
编译器分类.版本.编译选项
标准库版本/第三库版本
http://www.zhihu.com/question/20201972

GCC使用的C++标准库是libstdc++
这是项目地址：http://gcc.gnu.org/libstdc++/

clang++用的C++库：
http://libcxx.llvm.org/
svn co http://llvm.org/svn/llvm-project/libcxx/trunk libcxx

/usr/include/c++/4.6/bits/stl_queue.h

windows下c++ 标准库路径
linux下c++ 标准库路径
http://www.cnblogs.com/qq78292959/archive/2012/03/21/2409378.html

Source Insight常用快捷键：
Ctrl + F 字符串全文搜索
选择一个变量或方法后右键Lookup References…就可以进行查找
Alt +, 后退；Alt+.前进.
Alt + G (或者F7) 打开Symbol Window.

source insight 3.5的注册码：
SI3US-361500-17409


make
http://www.ruanyifeng.com/blog/2015/03/build-website-with-make.html

http://blog.csdn.net/zengraoli/article/details/11522563
http://blog.csdn.net/windows_nt/article/details/9630567
http://blog.sina.com.cn/s/blog_5cf4a61d0100xr00.html
http://bbs.9ria.com/thread-206437-1-1.html
http://www.himigame.com/curl-libcurl/878.html
http://blog.csdn.net/w13770269691/article/details/8847800


平台类型：linux、windows
平台位数：32、64
平台动态链接库的依赖问题
指定编译器版本 	编译选项	Makefile方式编译?
编译器类型：编译可以用gcc/g++,而链接可以用gcc -lstdc++或者g++
编译器位数
编译.链接.运行时默认的文件查找路径及顺序，以及文件名
默认头文件.类库.命令的查找路径及顺序
平台开发时的api接口
http://www.cnblogs.com/zyl910/archive/2012/08/14/gcc64_make.html
http://tieba.baidu.com/p/234600296
http://blog.csdn.net/duguteng/article/details/22036561

c++调用第三方库，最好用源码来自己编译，避免c++因编译.链接带来的乱七八糟的问题。
编译.链接时：
默认头文件查找路径及头文件名
默认类库查找路径及库文件名
运行时：
默认类库查找路径及库文件名
编译：查看语法错误，因语法错误编译失败，出现类似“某某未定义”的错误。
链接：查找外部符号的定义，在链接时会出现“未处理的外部符号‘某某’，该符号在某某位置处被引用”的错误。

编译时系统默认.h文件的搜索路径及顺序：
1. gcc编译时，可以设置-I选项以指定头文件的搜索路径，如果指定多个路径，则按照顺序依次查找。
Makefile中指定.h文件的搜索路径，gcc/g++命令行中指定.h文件的搜索路径
".h" 先在当前目录下搜索，再在系统目录下搜索   
<.h> 只在系统目录下搜索
.h具体到文件/具体到目录，但不会递归去查找文件
2.通过查找gcc的环境变量C_INCLUDE_PATH/CPLUS_INCLUDE_PATH/OBJC_INCLUDE_PATH来搜索头文件位置。
3. 再找内定目录搜索，分别是
 /usr/include
 /usr/local/include
 /usr/lib/gcc-lib/i386-linux/2.95.2/include  (gcc-lib头文件目录)

链接：
默认命令.类库.头文件的查找路径及顺序
LIBRARY_PATH 连接时库文件的搜索路径
LD_LIBRARY_PATH运行时库文件的搜索路径
http://blog.chinaunix.net/uid-20620288-id-3157119.html
http://blog.csdn.net/statdm/article/details/7751000

eclipse中添加第三方库
http://blog.sina.com.cn/s/blog_6f74890d01018zsm.html
http://blog.163.com/baosongliang@126/blog/static/194935702013101335758601/
http://howtofix.pro/how-to-solveduring-startup-program-exited-with-code-0xc/

win平台关于加载dll文件的顺序，如下:
应用程序所在目录→当前目录→Windows SYSTEM目录→Windows目录→PATH环境变量指定的路径
Dependency Walker 、Process Explorer

Linux中以下命令可以查看可执行文件的依赖库：ldd a.out Makefile xxd
注意：在修改了 /etc/ld.so.conf 文件或者在系统中安装了新的函数库之后，需要运行一个命令：ldconfig ，该命令用来刷新系统的共享库缓存，即 /etc/ld.so.cache 文件
nm命令可以列出一个函数库文件中的符号表
nm、ar、ldd、ldconfig和ld.so 

gcc和g++的区别和联系是什么:
（1）gcc和g++都是GNU(组织)的一个编译器。
（2）后缀名为.c的程序和.cpp的程序g++都会当成是c++的源程序来处理。而gcc不然，gcc会把.c的程序处理成c程序。
（3）对于.cpp的程序，编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。（个人觉得这条是最重要的）	

编译器的工作过程
http://kb.cnblogs.com/page/508336/
开发者可以在编译阶段选择可执行文件连接外部函数库的方式：到底是编译时连接.静态连接  还是运行时连接.动态连接
现实中，大部分软件采用动态连接，共享库文件。这种动态共享的库文件，Linux平台是后缀名为.so的文件，Windows平台是.dll文件，Mac平台是.dylib文件。
动态连接是外部函数库不进入安装包，只在运行时动态引用。好处是安装包会比较小，多个应用程序可以共享库文件；
缺点是用户必须事先安装好库文件，而且版本和安装位置都必须符合要求，否则就不能正常运行。

不管怎么说， 函数指针.回调函数是继续自C语言的，因而，在C++中，应只在与C代码建立接口，或与已有的回调接口打交道时，才使用回调函数。除了上述情况，在C++中应使用虚拟方法或函数符（functor），而不是回调函数。

c++编译、链接：
在.h文件中，通过#define定义一个名字，并且通过条件编译#ifndef...#endif使得编译器可以根据这个名字是否被定义：避免类被多次定义
.h文件只是在预编译的时候完整拷贝其内容
#include的作用是在预编译的时候把它后面所写的那个文件的内容，完完整整地、一字不改地包含到当前的文件中来，别无其他。
只有.c/.cpp文件参与编译、链接。

一个符号在整个程序中可以被声明多次，但必须要且仅要被定义一次。试想，如果一个符号出现了两种不同的定义，编译器该听谁的？就会编译报错
.h头文件中只能存在变量或者函数的声明，而不要放定义。但是，这个规则是有三个例外的：类class的定义、全局的const对象、内联函数（inline）的定义
类的定义中包含着数据成员和函数成员。数据成员是要等到具体的对象被创建时才会被定义（分配空间），但函数成员却是需要在一开始就被定义的，这也就是我们通常所说的类的实现。
即只能在头文件中写形如：extern int a;和void f();的句子，这些才是声明。不能写上int a;或者void f() {}这样定义的句子
http://blog.csdn.net/xupan_jsj/article/details/7855090

Linux下c++编程：
1，使用gedit，或者任何文本编辑器（最好有语法高亮，自动缩进功能）编写您的代码。
2，编写代码时，使用标准库的函数和数据结构，或者其它已经实现的模块，或者linux系统API调用。
3，碰到不知道的标准库，或者linux API，使用man命令查询，没有的话，到网上查询。
4，编写makefile.	(自动生成Makefile文件：autoscan, aclocal, autoconf, automake这四个工具.)
5，在g++上添加 -g参数，加入调试符号。
6，使用gdb调试或者打印log测试。
7，去掉-g参数，release。
8，结束。
工具介绍：
gcc/g++ 编译器 
gdb 调试工具 
valgrind 内存泄露检查 
doxygen 文档组织工具
c++常用第三方库： GTK, QT,STL，boost、curl、socket库、解析xml/json库
---------------------------------------------------------------
.h: 
#ifndef
#define
#include
...
#endif

.cpp:
#include <iostream> 
using namespace std #即包名+类名

c++语法：
#define 宏名(参数) 宏变量.宏函数   即字符串替换  避免函数调用时进栈.出栈的性能影响。但不是类型安全的。宏函数的每个参数及整个宏体都最好加一个括号。
#pragma指示编译器完成一些特定的动作
typedef 定义类型别名
const	定义常量
#undef 宏名

模板即泛型：模板函数.模板类
template <typename T>
...declaration...
指针传递变量，被称为引用传递。
字符串即字符数组、字符指针
一维数组即一级指针，二维数组即二级指针
"\" makefile、shell、c++中用于连接本行和下一行。

template
extern可以置于变量或者函数前
在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？
extern “C” 则告诉编译器在编译fun这个函数名时按着C的规则去翻译
extern "C++" {代码块}
#pragma

#if
#ifndef    __HARDWARE_H__
#define    __HARDWARE_H__
  //代码部分
#endif
#ifdef
#else
#endif
c语言32个关键字
32位系统内存最大寻址范围0xffffffff，支持最大内存为2的32次方byte，即4GB

c++推荐使用单继承，而多继承时应使用virtual继承以避免二义性(调用函数不知道调用哪个基类的成员变量和函数、节省内存空间)
virtual继承和普通继承

virtual函数是基类中的接口，是派生类中的实现，基类的析构函数~必须是virtual的
virtual函数: 先调用自身的，在调用父类的。没有virtual则直接调用父类的
virtual函数用于父类指针指向子类对象时的多态的实现
虚函数的调用是在运行时确定的

只拥有纯虚函数的类是抽象类，不能被实例化
virtual函数：virtual void foo();
纯虚函数: virtual void foo()=0;

typedef定义类型别名
函数指针类型(typedef)	函数指针变量
二、函数指针变量与回调函数
C++不支持const函数指针，我们只能定义非const函数指针变量
函数如下
void foo(int a, int b)
{
    cout << a + b << endl;
}
1、直接定义函数指针
void (*pf)(int, int);   // 定义函数指针变量pf
     pf = foo;               // 赋值使其指向函数foo --- (1)
     pf = &foo;              // 赋值使其指向函数foo --- (2)
                             // (1)与(2)均ok
 
     pf(6, 7);               // 通过函数指针调用函数:输出13 --- (3)
     (*pf)(6, 7);            // 通过函数指针调用函数:输出13 --- (4)
                             // (3)与(4)均ok
2、利用类型别名定义
typedef void (*FunPtr)(int, int);　　// 定义函数指针类型
FunPtr pf;              // 定义函数指针变量pf

     pf = foo;               // 赋值使其指向函数foo --- (1)
     pf = &foo;              // 赋值使其指向函数foo --- (2)
                             // (1)与(2)均ok
 
     pf(6, 7);               // 通过函数指针调用函数:输出13 --- (3)
     (*pf)(6, 7);            // 通过函数指针调用函数:输出13 --- (4)
                             // (3)与(4)均ok

指针常量 char* const pStr = "123";(pStr值不可修改，但*pStr可修改)
指向常量的指针 const char* pStr = "123";(pStr可修改，但*pStr不可修改)
指针.数组：是一个数组，数组中的每个元素都是指针。
数组.指针：是一个指针，指向数组的指针
指针.函数：是一个函数，函数的返回值是是一个指针。
函数.指针：是一个指针，指向函数的指针。函数指针作为参数，用来实现回调函数。
字符数组或者字符指针以'\0'结尾。

c：
定义：int (*pFunction)(float,char,char)=NULL;
赋值：pFunction=&func2;
调用：(*pFunction)(10.0,’a’,’b’);
c++:
定义：int (MyClass::*pMemberFunction)(float,char,char)=NULL;
赋值：pMemberFunction= &mc.func1;  //必须要加取地址符号
调用：(mc.*pMemberFunction)(10.0,’a’,’b’);
指针函数：是一个函数，返回值类型是指针。
函数的返回值类型是一个函数指针：
float (* func(char args) ) (float ,float)
其函数名为func，其参数的个数为1个char args；
其返回变量类型为：float(*)(float,float)，是一个函数指针。

*和[]对指针降级即解引用，操作指针所指向的地址的值
http://blog.csdn.net/sruru/article/details/7916296
http://www.cnblogs.com/charley_yang/archive/2010/12/15/1907384.html

c++构造函数、~析构函数
c++静态属性成员初始化：只能在.cpp文件的方法的外边初始化，初始化格式为：类型 类名::变量名 = 变量值
new创建对象、new的返回值是一个指针
this指代当前指针
手动分配和释放内存: new 和delete一定要成对使用。
(指针初始化,避免野指针：pointer=NULL;pointer=new Object(),指针释放：delete pointer;pointer=NULL;)
delete指针后，一定要将该指针赋值为0	(避免野指针、若同一指针delete两次，程序可能会崩溃

c++如何创建一个对象/引用？ 定义一个对象，并直接调用方法。
指针间的赋值 	(2张背景地图循环移动) 
一级指针、二级指针，变量是0级指针

命名空间.类名::
指针->
对象.	(引用即对象的别名)
*定义指针、取地址所存放的值		&取地址符、定义引用	
定义类：	: public 类名, : private 类名(多继承.实现，c++中没有定义接口/抽象类的关键字)
方法实现：	返回值类型 类名::方法名()			

final函数不能被重写
虚函数：父类引用指向子类对象时实现多态性。子类可实现也可不实现
纯虚函数：子类必须实现,相当于java接口中的方法。含有纯虚函数的类不能实例化。virtual void print(...)=0，声明函数时添加"=0"
关于虚函数，在多态当中，一定要将基类的析构函数设置为虚函数并将其实现，只有这样，才能够达到按对象构造的逆序来析构对象；
否则，析构的时候，只会析构基类的那一部分，那么派生类那一部分就无法成功析构了。

重写overrie：子类重新定义父类中有相同名称和参数的虚函数
重定义即隐藏redefine：子类重新定义父类中有相同名称的非虚函数 (参数可同.可不同)



函数指针与回调函数：函数指针类型、函数指针变量
宏定义
c++用指针来实现引用，实现址传递
结构体对象调用.

进程组.进程.线程池
异步IO的事件框架
http://www.zhihu.com/question/23156257
函数入口.生命周期.事件机制：调用流程

不同OS调度.管理线程的方式是不一样的
c++多线程同步：
使用新的mutex互斥锁机制，而不是过去普遍出现在内核中的semaphore信号量机制
软中断信号
-------------------------------------------------------------------------------------------------------------
OC语法：
调用方法用[]，调用属性用.
类型用()括起来，参数用 前缀+: 分割
方法用+、-来标识
定义属性用@property
定义协议即数据结构用<协议名>{...}
--------------------------------------------------------------------------------------------------
vs快捷键：

代码阅读：
Visual Assist X 快捷键：
Shift+Alt+S 字符串全文搜索/打开指定方法或变量
Shift+Alt+O 打开指定文件
Alt+M 打开当前文件中的指定方法
	
Alt+G：查看光标处变量或函数的定义.声明。	Ctrl+‘—’依次返回
Alt+O .h/.cpp切换
Shift+Alt+F 查看光标处的变量或函数所有调用
Ctrl+‘—’依次返回	依次前进

F12查看定义
Shift+F12:	查看调用
Ctrl+k.d   格式化代码
Shift+Alt+Enter: 切换全屏编辑
显示行数：工具->选项->文本编辑器->C/C++->行号

代码编写：
Alt+右箭头/Ctrl+j 代码自动补全
字符串重构
tab自动补全.确定
Ctrl+k.c注释   k.u取消注释
Ctrl+c 复制当前行
Ctrl+x、Ctrl+l	删除当前行
Ctrl+Shift+Enter 移至下一个空行
移动当前行
Ctrl+g	跳转到指定行
Shift+Tab	向左缩进

Ctrl+[.s	与文本编辑器同步
Ctrl+m.m 折叠.打开当前方法
Ctrl+m.o折叠所有方法 
Ctrl+m.p展开所有方法
Ctrl+k.s

调试：
不断注释调试
binary文件printLog调试
源码断点调试/源码printLog调试
Ctrl+Shift+F9: 删除全部断点

Visual Assist X 快捷键：
3、Alt + Shift + Q：鼠标定位到函数名上，若是在h文件中，按此快捷键会弹出右键菜单，里面有个选项--创建定义；若是在cpp文件中，则按此快捷键会弹出右键菜单，里面有一个选项--创建声明。 这在定义好接口之后，再来写实现时，配合Alt+O是非常快捷的。当然，这种情况下，鼠标右击与Alt+O配合会更快，嘿嘿。
4、Alt + Shift + R：当想改掉一个类名或是其他东西的命名时，可能已经有很多地方引用这个名称了，这时按下此快捷键，可以很方便的辅助你重命名。
配合ViEmu，以及visual studio本身的快捷键，这个开发环境简直太爽了。
快捷键参考：http://www.wholetomato.com/products/features/shortcut.asp

Alt+Left Arrow NavigateBack   后台
Ctrl+Shift+V Parse 弹出最近10个copy的内容菜单
Shift+Alt+Q RefactorContextMenu 弹出重构菜单
Shift+Alt+C RefactorCreateFromUsage
Alt+Left Arrow #NavigateBack   后台
Alt+Down Arraw #ScopeNext
Alt+Up Arraw #ScopePrevious

vs常用快捷键：
Ctrl+;	根据文件名打开指定文件
Ctrl+F	打开指定方法、全文搜索

Visual Assist X 10.7.1940.0代码自动补全插件



include路径:
可以将curl-7.21.1\include\curl目录拷贝到我们的工程目录下，也可以在VS工程里面指定引用目录
项目->属性->配置属性->C/C++->常规->附加包含目录->$(ProjectDir)
工具-》选项-》项目-》VC++目录-》
http://www.cnblogs.com/hwangbae/archive/2012/06/24/2560463.html
http://www.cnblogs.com/gulvzhe/archive/2012/03/14/2396230.html
http://www.cppblog.com/eping/archive/2010/09/06/126027.html
http://blog.csdn.net/lingdxuyan/article/details/4389634

lib库路径:
libcurld.dll拷贝到我们的应用程序目录下，然后在VS项目属性页中设置要包含的静态库。步骤：项目——>项目属性——>配置属性——>链接器”--“输入”--“附加依赖项”，
输入lib/libcurld_imp.lib 依具体情况而
error LNK2019：这种问题一般都是由于缺少相应的库文件
属性”--“链接器”--“输入”--“附加依赖项”






